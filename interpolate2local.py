# Autogenerated with SMOP 
from smop.core import *
# matlab/interpolate2local.m

    
@function
def interpolate2local(X_regular=None,Y_regular=None,Z_regular=None,xy_local=None,int_method=None,*args,**kwargs):
    varargin = interpolate2local.varargin
    nargin = interpolate2local.nargin

    # [z_local] = interpolate2local(X_regular,Y_regular,Z_regular,xy_local,int_method) 
# Interpolates thed ata to a refular grid and fill the gaps outside the convexhull.
# The data is outputed by the new regular grid in X, in Y. The data is a regular grid Z
# with in its thrid dimentsion the the different datasets.
# input:
# X_regular         Regular X-grid in km
# Y_regular         Regular Y_grid in km
# Z_regular         Regular Z-grid (multi-dimensional when having more than 1 dataset)
# int_method  		The interpoaltion method to be used. This is an optional input 
#                   argument. By default a triangular interpolation is performed.
# xy_local  		A local xy grid (preferably rotated to reduce interpolation 
#                   effects for points outside the convex hull). Needs to be specified
#                   as a 2 column matrix in km.
# output:
# z_local           The data observations that have been interpolated, with each
#                   dataset repressented by a column.
    
    #     Copyright (C) 2015  Bekaert David - University of Leeds
#     Email: eedpsb@leeds.ac.uk or davidbekaert.com
# 
#     This program is free software; you can redistribute it and/or modify
#     it under the terms of the GNU General Public License as published by
#     the Free Software Foundation; either version 2 of the License, or
#     (at your option) any later version.
# 
#     This program is distributed in the hope that it will be useful,
#     but WITHOUT ANY WARRANTY; without even the implied warranty of
#     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#     GNU General Public License for more details.
# 
#     You should have received a copy of the GNU General Public License along
#     with this program; if not, write to the Free Software Foundation, Inc.,
#     51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
    
    # setting the default interpolation method when needed
    flag_control_fig=0
# matlab/interpolate2local.m:38
    
    if nargin < 5:
        int_method=matlabarray([])
# matlab/interpolate2local.m:40
    
    if isempty(int_method) == 1:
        int_method='linear'
# matlab/interpolate2local.m:43
    
    # Convert the position grid back to a column vector
    x_regular=reshape(X_regular,[],1)
# matlab/interpolate2local.m:47
    clear('X_regular')
    y_regular=reshape(Y_regular,[],1)
# matlab/interpolate2local.m:49
    clear('Y_regular')
    # Converting the datagrid back to a column vector or a matrix
    n_datasets=size(Z_regular,3)
# matlab/interpolate2local.m:53
    n_gridpoints=length(y_regular)
# matlab/interpolate2local.m:54
    z_regular=reshape(Z_regular,n_gridpoints,n_datasets,1)
# matlab/interpolate2local.m:55
    z_local=NaN(cat(size(xy_local,1),n_datasets))
# matlab/interpolate2local.m:57
    for k in arange(1,n_datasets).reshape(-1):
        #     # alternative replace by tri interpolation
#     F = TriScatteredInterp(x_regular,y_regular,z_regular(:,k));
#     z_local_tri(:,k) = F(xy_local);
        z_local[:,k]=griddata(x_regular,y_regular,z_regular[:,k],xy_local[:,1],xy_local[:,2],int_method)
# matlab/interpolate2local.m:62
    
    if flag_control_fig == 1:
        figure
        scatter3(xy_local[:,1],xy_local[:,2],z_local[:,1],3,z_local[:,1],'filled')
        hold('on')
        scatter3(x_regular[:,1],y_regular[:,1],z_regular[:,1],50,z_regular[:,1],'filled')
        view(0,90)
        axis('xy')
        axis('equal')
        axis('tight')
        colorbar
        clear('x_regular','y_regular','z_regular')
    