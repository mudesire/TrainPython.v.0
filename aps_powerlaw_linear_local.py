# Autogenerated with SMOP 
from smop.core import *
# Trainmatlab.v.0/aps_powerlaw_linear_local.m

    
@function
def aps_powerlaw_linear_local(xy_local=None,local_origin=None,data_local1=None,data_local2=None,iterate=None,dimension_filter=None,save_path_outlier_window=None,ifg_number=None,ix_phase_nan_interferogram=None,debug_fig_linear=None,*args,**kwargs):
    varargin = aps_powerlaw_linear_local.varargin
    nargin = aps_powerlaw_linear_local.nargin

    # 
# Function that computes the linear relation between data_local1 and
# data_local2, assuming the slope is computed with data_local1 on the x-axis 
# data_local2 on the y-axis. Windows are increasing bottom up and start in
# the lower left corner.
    
    # Inputs:
# xy_local      Local grid, recomended to be rotated to reduce number of windows
#               outside the dataset, specified as a 2 column matrix in km.
# data_local1   Dataset 1 (matrix with n column bandfiltered datasets) X-axis
# data_local2   Dataset 2 (matrix with n column bandfiltered datasets) Y-axis
# 
# Optional inputs:
# iterate           A struct containign vairables that are computed for the
#                   first run and whicha re not recompeted for the other runs.
#                   This includes:
#                   window_ix: a variable struct containing which points 
#                               are in wich window.
#                   window_xy: the window positions that cover the data
#                   window_xy_extra: the window positions of the bounding box 
#                               around the data.
# crop_flag     	Set to 'y' to crop out an area. By default this is not done.
#               	When 'y': Filename = "area_ex.mat", with variable called lonlat.
#               	Use: lonlat=ginput; to select polygon around the to be cropped (out) area.
#               	Save as: save('area_ex.mat','lonlat');
    
    
    # OPTIONAL: visulize the estimation for an interferogram and a specific
# patch by changing the default variable "test" to 1 and "test_patch" to the
# specific patch number (counted columswize from top left in radar coordinates).
    
    #     Copyright (C) 2016  Bekaert David 
#     davidbekaert.com
# 
#     This program is free software; you can redistribute it and/or modify
#     it under the terms of the GNU General Public License as published by
#     the Free Software Foundation; either version 2 of the License, or
#     (at your option) any later version.
# 
#     This program is distributed in the hope that it will be useful,
#     but WITHOUT ANY WARRANTY; without even the implied warranty of
#     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#     GNU General Public License for more details.
# 
#     You should have received a copy of the GNU General Public License along
#     with this program; if not, write to the Free Software Foundation, Inc.,
#     51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
    
    
    # September 2010 --- Bekaert David --- Initial codings
    
    # 12/2012:  DB    Start from previous version of the code
# 01/2013:  DB    Allow for a wider range of bandfiltered data to be inputed.
# 02/2013:  DB    Adding estimation of slope from multiple bands
# 02/2013:  DB    Fix a bug when running for multiple datasets, i.e. when already 
#                 part of the window info is feeded directly into the function.
# 03/2013:  DB	  Allow for an extra argument (filepath), which when specified is
#                 used to save the results of the outlier rejection for each window.
# 03/2013:  DB	  Specify the number of patches including those for which the estimation
#                 is based on half a patch. These were introduced to reduce edge effects.
# 03/2013:  DB    Allow for an extra input argument that specifies the type
#                 of band filtering that was applied and displays it in the figures.
# 04/2013   DB:   Estimation of the slope at local grid by gaussian kernel
# 04/2013   DB:   Removing the extra input parameters and load them from the parm file
# 04/2013   DB:   Allow for the computation of the delay for each bandfilter
# 10/2013   DB:   Adding the option to have a single patch (n_patch=0)
#                 and using a planar estiamte for K
# 12/2013   DB:   Give the local slope also as output 
# 02/2014   DB:   Output the local slope for the bands too.
# 02/2014   DB:   Include a flag that allows for ridge-topo information to
#                 be used to constrain patching
# 05/2014   DB:   Fix dummy output when there is none.
# 07/2014   DB:   Include a cropped region for the patches option. Has been
#                 tested for ridges and when more than 1 window is left
# 06/2015   DB:   Change the default of the planar flag to 'n'
# 01/2016   DB:   Include the planar mode as parameter, fix for non-stamps
#                 processed data
# 02/2016   DB:   Include a variable which track NaN pixels and which
#                 updates the variable of slope_dataset
    
    ## defaults
# Defining input variables
    if nargin < 4:
        error('myApp:argChk',cat('Too few input arguments...\\nAbort... \\n'))
    
    flag_figure_checks=0
# Trainmatlab.v.0/aps_powerlaw_linear_local.m:88
    debug_fig=0
# Trainmatlab.v.0/aps_powerlaw_linear_local.m:89
    n_points_min=50
# Trainmatlab.v.0/aps_powerlaw_linear_local.m:90
    
    n_boot_runs=1000
# Trainmatlab.v.0/aps_powerlaw_linear_local.m:91
    
    bootstrap_flag=1
# Trainmatlab.v.0/aps_powerlaw_linear_local.m:92
    
    # Get matlab version as function arguments change with the matlab version
    matlab_version=version('-release')
# Trainmatlab.v.0/aps_powerlaw_linear_local.m:96
    
    matlab_version=str2num(matlab_version[1:4])
# Trainmatlab.v.0/aps_powerlaw_linear_local.m:97
    
    if nargin < 5 or isempty(iterate) == 1:
        window_ix=matlabarray([])
# Trainmatlab.v.0/aps_powerlaw_linear_local.m:101
        window_xy=matlabarray([])
# Trainmatlab.v.0/aps_powerlaw_linear_local.m:102
        window_xy_extra=matlabarray([])
# Trainmatlab.v.0/aps_powerlaw_linear_local.m:103
        ix_edges_window=matlabarray([])
# Trainmatlab.v.0/aps_powerlaw_linear_local.m:104
        compute_windows=1
# Trainmatlab.v.0/aps_powerlaw_linear_local.m:105
    else:
        compute_windows=0
# Trainmatlab.v.0/aps_powerlaw_linear_local.m:107
    
    if nargin < 6 or isempty(dimension_filter):
        dimension_filter=matlabarray([])
# Trainmatlab.v.0/aps_powerlaw_linear_local.m:110
    
    if isempty(dimension_filter) != 1 and length(dimension_filter) != size(data_local2,2):
        fprintf(cat('Warning: dimension_filter has different size then the dataset and will be ignored during plotting. \\n'))
        dimension_filter=matlabarray([])
# Trainmatlab.v.0/aps_powerlaw_linear_local.m:114
    
    if nargin < 7 or isempty(save_path_outlier_window):
        save_flag_outlier_windows=0
# Trainmatlab.v.0/aps_powerlaw_linear_local.m:118
    else:
        save_flag_outlier_windows=1
# Trainmatlab.v.0/aps_powerlaw_linear_local.m:120
    
    if nargin < 8:
        fprintf(cat('Assuming the power-law has been applied using one alpha and h0 \\n'))
        ifg_number=1
# Trainmatlab.v.0/aps_powerlaw_linear_local.m:124
    
    if nargin < 9:
        ix_phase_nan_interferogram=matlabarray([])
# Trainmatlab.v.0/aps_powerlaw_linear_local.m:127
    
    if nargin < 10:
        debug_fig_linear=0
# Trainmatlab.v.0/aps_powerlaw_linear_local.m:131
    
    fontsize=15
# Trainmatlab.v.0/aps_powerlaw_linear_local.m:134
    # getting the parameters from the parm list
    n_patches=getparm_aps('powerlaw_n_patches')
# Trainmatlab.v.0/aps_powerlaw_linear_local.m:138
    powerlaw_all_bands=getparm_aps('powerlaw_all_bands')
# Trainmatlab.v.0/aps_powerlaw_linear_local.m:139
    powerlaw_ridge_constraint=getparm_aps('powerlaw_ridge_constraint')
# Trainmatlab.v.0/aps_powerlaw_linear_local.m:140
    patch_overlap=getparm_aps('powerlaw_patch_overlap')
# Trainmatlab.v.0/aps_powerlaw_linear_local.m:141
    crop_flag=getparm_aps('crop_flag')
# Trainmatlab.v.0/aps_powerlaw_linear_local.m:142
    h0=getparm_aps('powerlaw_h0')
# Trainmatlab.v.0/aps_powerlaw_linear_local.m:143
    alpha=getparm_aps('powerlaw_alpha')
# Trainmatlab.v.0/aps_powerlaw_linear_local.m:144
    stamps_processed=getparm_aps('stamps_processed')
# Trainmatlab.v.0/aps_powerlaw_linear_local.m:145
    plane_mode=getparm_aps('powerlaw_plane_mode')
# Trainmatlab.v.0/aps_powerlaw_linear_local.m:146
    
    if strcmp(stamps_processed,'y'):
        load(psver)
    else:
        psver=2
# Trainmatlab.v.0/aps_powerlaw_linear_local.m:151
    
    # loading the topography information
    hgt_matfile=getparm_aps('hgt_matfile')
# Trainmatlab.v.0/aps_powerlaw_linear_local.m:154
    hgt=load(hgt_matfile)
# Trainmatlab.v.0/aps_powerlaw_linear_local.m:155
    hgt=hgt.hgt
# Trainmatlab.v.0/aps_powerlaw_linear_local.m:156
    ## Redefine the grid wrt lower left corner.
    xy_local_regrid=matlabarray(cat(min(xy_local[:,1]),min(xy_local[:,2])))
# Trainmatlab.v.0/aps_powerlaw_linear_local.m:160
    xy_local[:,2]=xy_local[:,2] - xy_local_regrid[:,2]
# Trainmatlab.v.0/aps_powerlaw_linear_local.m:161
    xy_local[:,1]=xy_local[:,1] - xy_local_regrid[:,1]
# Trainmatlab.v.0/aps_powerlaw_linear_local.m:162
    ## Computing the patch edges
# only perform operation this when it has not been done before
    if compute_windows == 1 and strcmpi(powerlaw_ridge_constraint,'n'):
        # size of the image in km
        width_x=(max(xy_local[:,1]) - min(xy_local[:,1]))
# Trainmatlab.v.0/aps_powerlaw_linear_local.m:172
        width_y=(max(xy_local[:,2]) - min(xy_local[:,2]))
# Trainmatlab.v.0/aps_powerlaw_linear_local.m:173
        heading=getparm_aps('heading')
# Trainmatlab.v.0/aps_powerlaw_linear_local.m:176
        if n_patches != 0:
            # Assuming the patches to be approximately square to find number of 
        # patches in x and y direction.
            patch_width=sqrt(dot(width_x,width_y) / n_patches)
# Trainmatlab.v.0/aps_powerlaw_linear_local.m:181
            n_patches_x=ceil(width_x / patch_width)
# Trainmatlab.v.0/aps_powerlaw_linear_local.m:182
            n_patches_y=ceil(width_y / patch_width)
# Trainmatlab.v.0/aps_powerlaw_linear_local.m:183
            fprintf(cat(num2str(n_patches_x),' patches (+2 for the edges) in x-dir \\n'))
            fprintf(cat(num2str(n_patches_y),' patches (+2 for the edges) in y-dir \\n'))
            # But allow in futuer for a different one in x and y direction.
            patch_overlap_x=copy(patch_overlap)
# Trainmatlab.v.0/aps_powerlaw_linear_local.m:189
            patch_overlap_y=copy(patch_overlap)
# Trainmatlab.v.0/aps_powerlaw_linear_local.m:190
            fprintf(cat(num2str(patch_overlap_x),' procent patch overlap in x direction \\n'))
            fprintf(cat(num2str(patch_overlap_y),' procent patch overlap in y direction \\n'))
            patch_width_x=width_x / (patch_overlap_x / 100 + dot((1 - patch_overlap_x / 100),n_patches_x))
# Trainmatlab.v.0/aps_powerlaw_linear_local.m:195
            patch_width_y=width_y / (patch_overlap_y / 100 + dot((1 - patch_overlap_y / 100),n_patches_y))
# Trainmatlab.v.0/aps_powerlaw_linear_local.m:196
            fprintf(cat('Patch width with overlap in x-direction: ',num2str(patch_width_x),'\\n'))
            fprintf(cat('Patch width with overlap in y-direction: ',num2str(patch_width_y),'\\n'))
            patch_c2c_y=patch_width_y - dot(patch_width_y,patch_overlap_y) / 100
# Trainmatlab.v.0/aps_powerlaw_linear_local.m:202
            patch_c2c_x=patch_width_x - dot(patch_width_x,patch_overlap_x) / 100
# Trainmatlab.v.0/aps_powerlaw_linear_local.m:203
            patch_c2c=max(cat(patch_c2c_y,patch_c2c_x))
# Trainmatlab.v.0/aps_powerlaw_linear_local.m:204
        else:
            fprintf('Use an individual window \\n')
            patch_width_x=copy(width_x)
# Trainmatlab.v.0/aps_powerlaw_linear_local.m:207
            patch_width_y=copy(width_y)
# Trainmatlab.v.0/aps_powerlaw_linear_local.m:208
            fprintf(cat('Patch width with overlap in x-direction: ',num2str(width_x),'\\n'))
            fprintf(cat('Patch width with overlap in y-direction: ',num2str(width_y),'\\n'))
        powerlaw_window_size=matlabarray(cat(patch_width_x,patch_width_y))
# Trainmatlab.v.0/aps_powerlaw_linear_local.m:213
        if exist('tca_support.mat') == 2:
            save(cat('tca_support.mat'),'-append','powerlaw_window_size')
        else:
            save(cat('tca_support.mat'),'powerlaw_window_size')
    else:
        if compute_windows == 1 and strcmpi(powerlaw_ridge_constraint,'y'):
            tca_support=load('tca_support.mat','powerlaw_ridges')
# Trainmatlab.v.0/aps_powerlaw_linear_local.m:222
            tca_support=tca_support.powerlaw_ridges
# Trainmatlab.v.0/aps_powerlaw_linear_local.m:223
            mountain_ridge=tca_support.mountain_ridge
# Trainmatlab.v.0/aps_powerlaw_linear_local.m:224
            hard_ridge_flag=tca_support.hard_ridge_flag
# Trainmatlab.v.0/aps_powerlaw_linear_local.m:225
            mountain_ridge=mountain_ridge[logical_not(cellfun('isempty',mountain_ridge))]
# Trainmatlab.v.0/aps_powerlaw_linear_local.m:227
            mountain_ridge[length(mountain_ridge) + 1]=tca_support.InSAR_convexhull
# Trainmatlab.v.0/aps_powerlaw_linear_local.m:228
            hard_ridge_flag=matlabarray(cat(hard_ridge_flag,0))
# Trainmatlab.v.0/aps_powerlaw_linear_local.m:229
            heading=getparm_aps('heading')
# Trainmatlab.v.0/aps_powerlaw_linear_local.m:232
            xy_rotatelocal_all=matlabarray([])
# Trainmatlab.v.0/aps_powerlaw_linear_local.m:235
            min_region=matlabarray([])
# Trainmatlab.v.0/aps_powerlaw_linear_local.m:236
            max_region=matlabarray([])
# Trainmatlab.v.0/aps_powerlaw_linear_local.m:237
            for kk in arange(1,length(mountain_ridge)).reshape(-1):
                # rotating the data
                xy_rotatelocal[kk],temp[kk]=ll2rotatelocal(mountain_ridge[kk],heading,local_origin,nargout=2)
# Trainmatlab.v.0/aps_powerlaw_linear_local.m:240
                xy_rotatelocal[kk]=round(xy_rotatelocal[kk])
# Trainmatlab.v.0/aps_powerlaw_linear_local.m:241
                max_region=max(cat([xy_rotatelocal[kk]],[max_region]))
# Trainmatlab.v.0/aps_powerlaw_linear_local.m:242
                min_region=min(cat([xy_rotatelocal[kk]],[min_region]))
# Trainmatlab.v.0/aps_powerlaw_linear_local.m:243
                clear('temp')
                # storing the InSAR bounding box for latter use
                if kk == length(mountain_ridge):
                    xy_InSAR_convexhull=xy_rotatelocal[kk]
# Trainmatlab.v.0/aps_powerlaw_linear_local.m:248
            matrix_patches=zeros(cat(max_region - min_region) + 1)
# Trainmatlab.v.0/aps_powerlaw_linear_local.m:253
            y_vector=matlabarray([])
# Trainmatlab.v.0/aps_powerlaw_linear_local.m:254
            x_vector=matlabarray([])
# Trainmatlab.v.0/aps_powerlaw_linear_local.m:255
            z_vector=matlabarray([])
# Trainmatlab.v.0/aps_powerlaw_linear_local.m:256
            for kk in arange(1,length(mountain_ridge)).reshape(-1):
                if hard_ridge_flag[kk] == 1:
                    z_ridge=10000
# Trainmatlab.v.0/aps_powerlaw_linear_local.m:260
                else:
                    z_ridge=100
# Trainmatlab.v.0/aps_powerlaw_linear_local.m:262
                clear('ix_lines')
                # shift the origin of the indexes
                ix_lines[:,1]=xy_rotatelocal[kk](arange(),1) - min_region[1,1] + 1
# Trainmatlab.v.0/aps_powerlaw_linear_local.m:267
                ix_lines[:,2]=xy_rotatelocal[kk](arange(),2) - min_region[1,2] + 1
# Trainmatlab.v.0/aps_powerlaw_linear_local.m:268
                for kkk in arange(1,length(ix_lines[:,1]) - 1).reshape(-1):
                    x_sampling=cat(arange(min(cat(ix_lines[kkk,1],ix_lines[kkk + 1,1])),max(cat(ix_lines[kkk,1],ix_lines[kkk + 1,1])))).T
# Trainmatlab.v.0/aps_powerlaw_linear_local.m:271
                    if length(x_sampling) <= 1:
                        # The x points are at the same coordinate, i.e. this is a
                # vertical line, change the sampling to be in y-direction.
                        y_sampling=cat(arange(min(cat(ix_lines[kkk,2],ix_lines[kkk + 1,2])),max(cat(ix_lines[kkk,2],ix_lines[kkk + 1,2])))).T
# Trainmatlab.v.0/aps_powerlaw_linear_local.m:275
                        if length(y_sampling) > 1:
                            clear('x_sampling')
                            x_sampling=interp1(ix_lines[kkk:kkk + 1,2],ix_lines[kkk:kkk + 1,1],y_sampling)
# Trainmatlab.v.0/aps_powerlaw_linear_local.m:278
                            x_vector=matlabarray(cat([x_vector],[x_sampling]))
# Trainmatlab.v.0/aps_powerlaw_linear_local.m:279
                            y_vector=matlabarray(cat([y_vector],[y_sampling]))
# Trainmatlab.v.0/aps_powerlaw_linear_local.m:280
                            z_vector=matlabarray(cat([z_vector],[multiply(z_ridge,ones(size(y_sampling)))]))
# Trainmatlab.v.0/aps_powerlaw_linear_local.m:281
                        else:
                            # this is a single point -- appears to occur double in
                    # the line.
                            x_vector=matlabarray(cat([x_vector],[x_sampling[1]]))
# Trainmatlab.v.0/aps_powerlaw_linear_local.m:285
                            y_vector=matlabarray(cat([y_vector],[y_sampling[1]]))
# Trainmatlab.v.0/aps_powerlaw_linear_local.m:286
                            z_vector=matlabarray(cat([z_vector],[multiply(z_ridge,ones(size(y_sampling)))]))
# Trainmatlab.v.0/aps_powerlaw_linear_local.m:287
                    else:
                        # do the interpolation in x-direction
                        if logical_not(isempty(x_sampling)):
                            y_sampling=interp1(ix_lines[kkk:kkk + 1,1],ix_lines[kkk:kkk + 1,2],x_sampling)
# Trainmatlab.v.0/aps_powerlaw_linear_local.m:293
                            x_vector=matlabarray(cat([x_vector],[x_sampling]))
# Trainmatlab.v.0/aps_powerlaw_linear_local.m:295
                            y_vector=matlabarray(cat([y_vector],[y_sampling]))
# Trainmatlab.v.0/aps_powerlaw_linear_local.m:296
                            z_vector=matlabarray(cat([z_vector],[multiply(z_ridge,ones(size(y_sampling)))]))
# Trainmatlab.v.0/aps_powerlaw_linear_local.m:297
                            if abs(mean(diff(y_sampling))) > 1.5:
                                # step in y direction is large -- change
                        # interpolation direction to scope with this
                                y_sampling=cat(arange(min(cat(ix_lines[kkk,2],ix_lines[kkk + 1,2])),max(cat(ix_lines[kkk,2],ix_lines[kkk + 1,2])))).T
# Trainmatlab.v.0/aps_powerlaw_linear_local.m:304
                                clear('x_sampling')
                                x_sampling=interp1(ix_lines[kkk:kkk + 1,2],ix_lines[kkk:kkk + 1,1],y_sampling)
# Trainmatlab.v.0/aps_powerlaw_linear_local.m:306
                                x_vector=matlabarray(cat([x_vector],[x_sampling]))
# Trainmatlab.v.0/aps_powerlaw_linear_local.m:307
                                y_vector=matlabarray(cat([y_vector],[y_sampling]))
# Trainmatlab.v.0/aps_powerlaw_linear_local.m:308
                                z_vector=matlabarray(cat([z_vector],[multiply(z_ridge,ones(size(y_sampling)))]))
# Trainmatlab.v.0/aps_powerlaw_linear_local.m:309
                    clear('x_sampling','y_sampling')
                clear('z_ridge')
            x_vector=round(x_vector)
# Trainmatlab.v.0/aps_powerlaw_linear_local.m:318
            y_vector=round(y_vector)
# Trainmatlab.v.0/aps_powerlaw_linear_local.m:319
            ix=sub2ind(size(matrix_patches),x_vector,y_vector)
# Trainmatlab.v.0/aps_powerlaw_linear_local.m:321
            matrix_patches[ix]=z_vector
# Trainmatlab.v.0/aps_powerlaw_linear_local.m:322
            matrix_patches=matrix_patches.T
# Trainmatlab.v.0/aps_powerlaw_linear_local.m:323
            H=fspecial('average',2)
# Trainmatlab.v.0/aps_powerlaw_linear_local.m:327
            matrix_patches_mean=imfilter(matrix_patches,H,'replicate')
# Trainmatlab.v.0/aps_powerlaw_linear_local.m:328
            matrix_patches_mean[matrix_patches_mean >= 1000]=10000
# Trainmatlab.v.0/aps_powerlaw_linear_local.m:329
            matrix_patches_mean[matrix_patches_mean > logical_and(0,matrix_patches_mean) < 1000]=100
# Trainmatlab.v.0/aps_powerlaw_linear_local.m:330
            clear('H')
            # shifting the grid axis to the same as that of the InSAR points
            x_temp=cat(arange(min_region[1],max_region[1])) - xy_local_regrid[:,1]
# Trainmatlab.v.0/aps_powerlaw_linear_local.m:335
            y_temp=cat(arange(min_region[2],max_region[2])) - xy_local_regrid[:,2]
# Trainmatlab.v.0/aps_powerlaw_linear_local.m:336
            xy_InSAR_convexhull[:,1]=xy_InSAR_convexhull[:,1] - xy_local_regrid[:,1]
# Trainmatlab.v.0/aps_powerlaw_linear_local.m:338
            xy_InSAR_convexhull[:,2]=xy_InSAR_convexhull[:,2] - xy_local_regrid[:,2]
# Trainmatlab.v.0/aps_powerlaw_linear_local.m:339
            Xmesh_patch_regions,Ymesh_patch_regions=meshgrid(x_temp,y_temp,nargout=2)
# Trainmatlab.v.0/aps_powerlaw_linear_local.m:343
            patch_regions=watershed(matrix_patches_mean)
# Trainmatlab.v.0/aps_powerlaw_linear_local.m:346
            patch_regions=double(patch_regions)
# Trainmatlab.v.0/aps_powerlaw_linear_local.m:347
            ix_row,ix_column=find(patch_regions == 0,nargout=2)
# Trainmatlab.v.0/aps_powerlaw_linear_local.m:350
            ix_zeros=sub2ind(size(patch_regions),ix_row,ix_column)
# Trainmatlab.v.0/aps_powerlaw_linear_local.m:351
            xy_edges=cat(ix_column,ix_row) + repmat(xy_local_regrid,size(ix_column,1),1)
# Trainmatlab.v.0/aps_powerlaw_linear_local.m:354
            window_edges_ll=rotatelocal2ll(xy_edges,heading,local_origin)
# Trainmatlab.v.0/aps_powerlaw_linear_local.m:355
            Xmesh_patch_regions_temp=reshape(Xmesh_patch_regions,[],1)
# Trainmatlab.v.0/aps_powerlaw_linear_local.m:358
            Ymesh_patch_regions_temp=reshape(Ymesh_patch_regions,[],1)
# Trainmatlab.v.0/aps_powerlaw_linear_local.m:359
            patch_regions_temp=reshape(patch_regions,[],1)
# Trainmatlab.v.0/aps_powerlaw_linear_local.m:360
            patch_regions_temp[ix_zeros]=[]
# Trainmatlab.v.0/aps_powerlaw_linear_local.m:361
            Xmesh_patch_regions_temp[ix_zeros]=[]
# Trainmatlab.v.0/aps_powerlaw_linear_local.m:362
            Ymesh_patch_regions_temp[ix_zeros]=[]
# Trainmatlab.v.0/aps_powerlaw_linear_local.m:363
            z=griddata_version_control(Xmesh_patch_regions_temp,Ymesh_patch_regions_temp,patch_regions_temp,Xmesh_patch_regions[ix_zeros],Ymesh_patch_regions[ix_zeros],'nearest',matlab_version)
# Trainmatlab.v.0/aps_powerlaw_linear_local.m:366
            patch_regions[ix_zeros]=z
# Trainmatlab.v.0/aps_powerlaw_linear_local.m:367
            clear('z')
            # removing those watershed that are not part of the insar region
            patch_regions_temp=reshape(patch_regions,[],1)
# Trainmatlab.v.0/aps_powerlaw_linear_local.m:372
            Xmesh_patch_regions_vector=reshape(Xmesh_patch_regions,[],1)
# Trainmatlab.v.0/aps_powerlaw_linear_local.m:373
            Ymesh_patch_regions_vector=reshape(Ymesh_patch_regions,[],1)
# Trainmatlab.v.0/aps_powerlaw_linear_local.m:374
            IN=inpolygon(Xmesh_patch_regions_vector,Ymesh_patch_regions_vector,xy_InSAR_convexhull[:,1],xy_InSAR_convexhull[:,2])
# Trainmatlab.v.0/aps_powerlaw_linear_local.m:375
            patch_regions_temp[IN]=[]
# Trainmatlab.v.0/aps_powerlaw_linear_local.m:376
            non_patches_pot=unique(patch_regions_temp)
# Trainmatlab.v.0/aps_powerlaw_linear_local.m:379
            non_patches_pot[isnan(non_patches_pot)]=[]
# Trainmatlab.v.0/aps_powerlaw_linear_local.m:380
            # region, as there might eb a slight grid offset. Otherwize keep the
    # patch as a valid patch.
            non_patches=matlabarray([])
# Trainmatlab.v.0/aps_powerlaw_linear_local.m:386
            for kk in arange(1,length(non_patches_pot)).reshape(-1):
                count=sum(non_patches_pot[kk] == patch_regions_temp)
# Trainmatlab.v.0/aps_powerlaw_linear_local.m:388
                count_total=sum(sum(non_patches_pot[kk] == patch_regions))
# Trainmatlab.v.0/aps_powerlaw_linear_local.m:389
                if dot((count / count_total),100) > 10:
                    non_patches=matlabarray(cat([non_patches],[non_patches_pot[kk]]))
# Trainmatlab.v.0/aps_powerlaw_linear_local.m:391
            # removing those bad located patched from the watershed
            for kk in arange(1,length(non_patches)).reshape(-1):
                patch_regions[patch_regions == non_patches[kk]]=NaN
# Trainmatlab.v.0/aps_powerlaw_linear_local.m:396
            # redefine the counting of the patches from 1 to number of patches
            patch_id=unique(patch_regions)
# Trainmatlab.v.0/aps_powerlaw_linear_local.m:400
            patch_id[isnan(patch_id)]=[]
# Trainmatlab.v.0/aps_powerlaw_linear_local.m:401
            n_patches=length(patch_id)
# Trainmatlab.v.0/aps_powerlaw_linear_local.m:403
            for k in arange(1,n_patches).reshape(-1):
                patch_regions[patch_regions == patch_id[k]]=dot(- 2,n_patches) + k
# Trainmatlab.v.0/aps_powerlaw_linear_local.m:405
            patch_regions=patch_regions + dot(2,n_patches)
# Trainmatlab.v.0/aps_powerlaw_linear_local.m:407
            if flag_figure_checks == 1 and debug_fig == 1:
                figure
                plot(xy_local[:,1],xy_local[:,2],'k.')
                axis('equal')
                axis('tight')
                hold('on')
                plot(xy_InSAR_convexhull[:,1],xy_InSAR_convexhull[:,2],'r-')
                figure
                imagesc(matrix_patches)
                axis('equal')
                axis('tight')
                axis('xy')
                figure
                imagesc(matrix_patches_mean)
                axis('equal')
                axis('tight')
                axis('xy')
                figure
                imagesc(patch_regions)
                axis('equal')
                axis('tight')
                axis('xy')
    
    ## determining the points in each window 
# only perform patch point computation when it has not been done before.
# doing only onces will save time for other interferograms
    n_points=size(data_local1,1)
# Trainmatlab.v.0/aps_powerlaw_linear_local.m:445
    ix_window=matlabarray([])
# Trainmatlab.v.0/aps_powerlaw_linear_local.m:446
    
    if compute_windows == 1 and strcmpi(powerlaw_ridge_constraint,'n'):
        # this is the patch approach.
    # Paches are increasing bottom up and start in the lower left corner.
        if n_patches == 0:
            # take only an individual window
            window_ix[1]=cat(arange(1,n_points)).T
# Trainmatlab.v.0/aps_powerlaw_linear_local.m:452
            window_xy[1,1]=min(xy_local[:,1]) + width_x / 2
# Trainmatlab.v.0/aps_powerlaw_linear_local.m:453
            window_xy[1,2]=min(xy_local[:,2]) + width_y / 2
# Trainmatlab.v.0/aps_powerlaw_linear_local.m:454
            window_xy_extra=matlabarray([])
# Trainmatlab.v.0/aps_powerlaw_linear_local.m:455
            ix_edges_window=matlabarray([])
# Trainmatlab.v.0/aps_powerlaw_linear_local.m:456
            w_d=ones(cat(n_points,1))
# Trainmatlab.v.0/aps_powerlaw_linear_local.m:457
        else:
            ixy_local=matlabarray(cat(cat(arange(1,n_points)).T,xy_local))
# Trainmatlab.v.0/aps_powerlaw_linear_local.m:459
            counter=1
# Trainmatlab.v.0/aps_powerlaw_linear_local.m:460
            counter_all=1
# Trainmatlab.v.0/aps_powerlaw_linear_local.m:461
            for i in arange(1,n_patches_x + 2).reshape(-1):
                # search for the points in the window
                x_bounds=cat(dot(dot((i - 1),patch_width_x),(1 - patch_overlap_x / 100)),dot(dot((i - 1),patch_width_x),(1 - patch_overlap_x / 100)) + patch_width_x) - patch_width_x / 2
# Trainmatlab.v.0/aps_powerlaw_linear_local.m:464
                ix_temp=find(x_bounds[1] <= logical_and(ixy_local[:,2],ixy_local[:,2]) < x_bounds[2])
# Trainmatlab.v.0/aps_powerlaw_linear_local.m:465
                ixy_local_temp=ixy_local[ix_temp,:]
# Trainmatlab.v.0/aps_powerlaw_linear_local.m:466
                clear('ix_temp')
                for k in arange(1,n_patches_y + 2).reshape(-1):
                    # search for the points in the window
                    y_bounds=cat(dot(dot((k - 1),patch_width_y),(1 - patch_overlap_y / 100)),dot(dot((k - 1),patch_width_y),(1 - patch_overlap_y / 100)) + patch_width_y) - patch_width_y / 2
# Trainmatlab.v.0/aps_powerlaw_linear_local.m:470
                    ix_temp=find(y_bounds[1] <= logical_and(ixy_local_temp[:,3],ixy_local_temp[:,3]) < y_bounds[2])
# Trainmatlab.v.0/aps_powerlaw_linear_local.m:471
                    ix=ixy_local_temp[ix_temp,1]
# Trainmatlab.v.0/aps_powerlaw_linear_local.m:472
                    clear('ix_temp')
                    # keeping only those windows were there is actual data, and
                # were there are more than n_points_min
                    if isempty(ix) != 1 and length(ix) >= n_points_min:
                        # saving the data back into the struct
                        window_ix[counter]=ix
# Trainmatlab.v.0/aps_powerlaw_linear_local.m:479
                        window_xy[counter,1]=x_bounds[1] + (x_bounds[2] - x_bounds[1]) / 2
# Trainmatlab.v.0/aps_powerlaw_linear_local.m:482
                        window_xy[counter,2]=y_bounds[1] + (y_bounds[2] - y_bounds[1]) / 2
# Trainmatlab.v.0/aps_powerlaw_linear_local.m:483
                        # it can be converted to lon lat later on;
                        window_box[counter]=cat(cat([x_bounds[1]],[x_bounds[2]],[x_bounds[2]],[x_bounds[1]],[x_bounds[1]]),cat([y_bounds[1]],[y_bounds[1]],[y_bounds[2]],[y_bounds[2]],[y_bounds[1]]))
# Trainmatlab.v.0/aps_powerlaw_linear_local.m:487
                        if flag_figure_checks == 1:
                            patch_colors=jet(dot((n_patches_x + 2),(n_patches_y + 2)))
# Trainmatlab.v.0/aps_powerlaw_linear_local.m:491
                            if counter == 1:
                                h1=figure('name','grid')
# Trainmatlab.v.0/aps_powerlaw_linear_local.m:493
                            else:
                                figure(h1)
                                hold('on')
                            plot(window_xy[counter,1],window_xy[counter,2],'o','color',patch_colors[counter,:])
                            hold('on')
                            plot(cat(x_bounds[1],x_bounds[2],x_bounds[2],x_bounds[1],x_bounds[1]),cat(y_bounds[1],y_bounds[1],y_bounds[2],y_bounds[2],y_bounds[1]),'-','color',patch_colors[counter,:])
                            axis('equal')
                            axis('tight')
                            xlim(cat(0,width_x))
                            ylim(cat(0,width_y))
                        # saving the orignal window number for the windows with points
                        ix_window[counter]=counter_all
# Trainmatlab.v.0/aps_powerlaw_linear_local.m:509
                        counter=counter + 1
# Trainmatlab.v.0/aps_powerlaw_linear_local.m:510
                    counter_all=counter_all + 1
# Trainmatlab.v.0/aps_powerlaw_linear_local.m:513
                    clear('ix')
            clear('x_bounds')
            clear('y_bounds')
            clear('counter')
            # convert the windows boxes into lon lats and save them for support
        # information
            for kkk in arange(1,length(window_box)).reshape(-1):
                window_box_temp=window_box[kkk] + repmat(xy_local_regrid,size(window_box[kkk],1),1)
# Trainmatlab.v.0/aps_powerlaw_linear_local.m:522
                window_box_ll[kkk]=rotatelocal2ll(window_box_temp,heading,local_origin)
# Trainmatlab.v.0/aps_powerlaw_linear_local.m:523
            window_xy_temp=window_xy + repmat(xy_local_regrid,size(window_xy,1),1)
# Trainmatlab.v.0/aps_powerlaw_linear_local.m:525
            window_box_center_ll=rotatelocal2ll(window_xy_temp,heading,local_origin)
# Trainmatlab.v.0/aps_powerlaw_linear_local.m:526
            powerlaw_windows.window_box_ll = copy(window_box_ll)
# Trainmatlab.v.0/aps_powerlaw_linear_local.m:530
            powerlaw_windows.window_box_center_ll = copy(window_box_center_ll)
# Trainmatlab.v.0/aps_powerlaw_linear_local.m:531
            #         keyboard
            if exist('tca_support.mat') == 2:
                save(cat('tca_support.mat'),'-append','powerlaw_windows')
            else:
                save(cat('tca_support.mat'),'powerlaw_windows')
            clear('window_box_ll')
            # the windows that are edges:
            edges=matlabarray(cat(arange(1,dot((n_patches_x + 2),(n_patches_y + 2)),n_patches_y + dot(2(n_patches_y + 2),(n_patches_x + 2)) - (n_patches_y + 2) + 1),arange(1,dot((n_patches_y + 2),(n_patches_x + 2)) - n_patches_y + 1,n_patches_y + 2),arange(n_patches_y + 2,dot((n_patches_y + 2),(n_patches_x + 2)),n_patches_y + 2)))
# Trainmatlab.v.0/aps_powerlaw_linear_local.m:542
            edges=unique(edges)
# Trainmatlab.v.0/aps_powerlaw_linear_local.m:543
            edges,temp,ix_edges_window=intersect(edges,ix_window,nargout=3)
# Trainmatlab.v.0/aps_powerlaw_linear_local.m:545
            clear('counter_all')
            clear('edges')
            clear('temp')
            powerlaw_windows_edge=copy(ix_edges_window)
# Trainmatlab.v.0/aps_powerlaw_linear_local.m:548
            if exist('tca_support.mat') == 2:
                save(cat('tca_support.mat'),'-append','powerlaw_windows_edge')
            else:
                save(cat('tca_support.mat'),'powerlaw_windows_edge')
            clear('window_box_ll')
            # getting the final number of windows
            n_windows=length(window_ix)
# Trainmatlab.v.0/aps_powerlaw_linear_local.m:557
            X_points=repmat(xy_local[:,1],1,n_windows)
# Trainmatlab.v.0/aps_powerlaw_linear_local.m:560
            Y_points=repmat(xy_local[:,2],1,n_windows)
# Trainmatlab.v.0/aps_powerlaw_linear_local.m:561
            X_windows=repmat(window_xy[:,1].T,n_points,1)
# Trainmatlab.v.0/aps_powerlaw_linear_local.m:562
            Y_windows=repmat(window_xy[:,2].T,n_points,1)
# Trainmatlab.v.0/aps_powerlaw_linear_local.m:563
            Distance=sqrt((X_points - X_windows) ** 2 + (Y_points - Y_windows) ** 2)
# Trainmatlab.v.0/aps_powerlaw_linear_local.m:564
            clear('X_points')
            clear('Y_points')
            clear('X_windows')
            clear('Y_windows')
            # Compute the gaussian weight based on distance
            w_d=normpdf(Distance,0,patch_c2c)
# Trainmatlab.v.0/aps_powerlaw_linear_local.m:569
            if flag_figure_checks == 1:
                figure('Name','Weighting based on Distance')
                Distance_temp=cat(arange(min(min(Distance)),max(max(Distance)),(max(max(Distance)) - min(min(Distance))) / 100)).T
# Trainmatlab.v.0/aps_powerlaw_linear_local.m:572
                weights_temp=normpdf(Distance_temp,0,patch_c2c)
# Trainmatlab.v.0/aps_powerlaw_linear_local.m:573
                plot(Distance_temp,weights_temp,'b.-')
            clear('Distance')
        # getting the variables in a structure to load on the next run
        iterate.window_ix = copy(window_ix)
# Trainmatlab.v.0/aps_powerlaw_linear_local.m:580
        iterate.window_xy = copy(window_xy)
# Trainmatlab.v.0/aps_powerlaw_linear_local.m:581
        iterate.window_xy_extra = copy(window_xy_extra)
# Trainmatlab.v.0/aps_powerlaw_linear_local.m:582
        iterate.ix_edges_window = copy(ix_edges_window)
# Trainmatlab.v.0/aps_powerlaw_linear_local.m:583
        iterate.w_d = copy(w_d)
# Trainmatlab.v.0/aps_powerlaw_linear_local.m:584
        # they will be ignored on the next run
        ridges_flag='n'
# Trainmatlab.v.0/aps_powerlaw_linear_local.m:587
        patch_regions=matlabarray([])
# Trainmatlab.v.0/aps_powerlaw_linear_local.m:588
        Ymesh_patch_regions=matlabarray([])
# Trainmatlab.v.0/aps_powerlaw_linear_local.m:589
        Xmesh_patch_regions=matlabarray([])
# Trainmatlab.v.0/aps_powerlaw_linear_local.m:590
        iterate.ridges_flag = copy(ridges_flag)
# Trainmatlab.v.0/aps_powerlaw_linear_local.m:592
        iterate.patch_regions = copy(patch_regions)
# Trainmatlab.v.0/aps_powerlaw_linear_local.m:593
        iterate.Ymesh_patch_regions = copy(Ymesh_patch_regions)
# Trainmatlab.v.0/aps_powerlaw_linear_local.m:594
        iterate.Xmesh_patch_regions = copy(Xmesh_patch_regions)
# Trainmatlab.v.0/aps_powerlaw_linear_local.m:595
    else:
        if compute_windows == 1 and strcmpi(powerlaw_ridge_constraint,'y'):
            # this is the ridges approach
            # in the previous section patch_regions where defined.
    # here all the PS poitns are interpolated based onthe patch region,
    # giving a patch id for point.
            z_points=interp2(Xmesh_patch_regions,Ymesh_patch_regions,patch_regions,xy_local[:,1],xy_local[:,2],'nearest')
# Trainmatlab.v.0/aps_powerlaw_linear_local.m:604
            if flag_figure_checks == 1:
                figure
                scatter3(xy_local[:,1],xy_local[:,2],z_points,3,z_points,'filled')
                view(0,90)
                axis('equal')
                axis('tight')
            # construct the iterate variable and populate the data
            for kk in arange(1,n_patches).reshape(-1):
                ix=find(z_points == kk)
# Trainmatlab.v.0/aps_powerlaw_linear_local.m:616
                window_ix[kk]=ix
# Trainmatlab.v.0/aps_powerlaw_linear_local.m:617
                window_xy[kk,:]=mean(xy_local[ix,:])
# Trainmatlab.v.0/aps_powerlaw_linear_local.m:618
            # coordinates for the window edges:
            window_xy_centers=window_xy + repmat(xy_local_regrid,size(window_xy,1),1)
# Trainmatlab.v.0/aps_powerlaw_linear_local.m:622
            window_center_ll=rotatelocal2ll(window_xy_centers,heading,local_origin)
# Trainmatlab.v.0/aps_powerlaw_linear_local.m:623
            clear('window_xy_centers')
            if flag_figure_checks == 1:
                figure('name','Patch definition')
                plot(window_edges_ll[:,1],window_edges_ll[:,2],'k.')
                hold('on')
                for kk in arange(1,size(window_center_ll,1)).reshape(-1):
                    text(window_center_ll[kk,1],window_center_ll[kk,2],cat(num2str(kk)),'color','r','fontsize',fontsize)
                    plot(window_center_ll[kk,1],window_center_ll[kk,2],'r.')
                axis('equal')
                axis('tight')
                xlabel('longitude','fontsize',fontsize)
            # getting the final number of windows
            n_windows=length(window_ix)
# Trainmatlab.v.0/aps_powerlaw_linear_local.m:642
            for kk in arange(1,n_windows).reshape(-1):
                X_windows=repmat(window_xy[:,1].T,n_windows,1)
# Trainmatlab.v.0/aps_powerlaw_linear_local.m:646
                Y_windows=repmat(window_xy[:,2].T,n_windows,1)
# Trainmatlab.v.0/aps_powerlaw_linear_local.m:647
                Distance_windows=sqrt((X_windows - X_windows.T) ** 2 + (Y_windows - Y_windows.T) ** 2)
# Trainmatlab.v.0/aps_powerlaw_linear_local.m:648
                Distance_windows_sorted=sort(Distance_windows,1)
# Trainmatlab.v.0/aps_powerlaw_linear_local.m:649
                patch_c2c=dot(2 / 3,mean(Distance_windows_sorted[2,:]))
# Trainmatlab.v.0/aps_powerlaw_linear_local.m:650
            # Computing weights based on distance from the points to the windows centers
            X_points=repmat(xy_local[:,1],1,n_windows)
# Trainmatlab.v.0/aps_powerlaw_linear_local.m:655
            Y_points=repmat(xy_local[:,2],1,n_windows)
# Trainmatlab.v.0/aps_powerlaw_linear_local.m:656
            X_windows=repmat(window_xy[:,1].T,n_points,1)
# Trainmatlab.v.0/aps_powerlaw_linear_local.m:657
            Y_windows=repmat(window_xy[:,2].T,n_points,1)
# Trainmatlab.v.0/aps_powerlaw_linear_local.m:658
            Distance=sqrt((X_points - X_windows) ** 2 + (Y_points - Y_windows) ** 2)
# Trainmatlab.v.0/aps_powerlaw_linear_local.m:659
            clear('X_points')
            clear('Y_points')
            clear('X_windows')
            clear('Y_windows')
            dimensions=ceil(max(xy_local)) - floor(min(xy_local))
# Trainmatlab.v.0/aps_powerlaw_linear_local.m:663
            grid_resolution=10
# Trainmatlab.v.0/aps_powerlaw_linear_local.m:664
            Xgrid,Ygrid=meshgrid(cat(arange(dot(- 1,ceil(patch_c2c / grid_resolution)),dimensions[1] + ceil(patch_c2c / grid_resolution),grid_resolution)),cat(arange(dot(- 1,ceil(patch_c2c / grid_resolution)),dimensions[2] + ceil(patch_c2c / grid_resolution),grid_resolution)),nargout=2)
# Trainmatlab.v.0/aps_powerlaw_linear_local.m:667
            clear('dimensions')
            dimensions_grid=size(Xgrid)
# Trainmatlab.v.0/aps_powerlaw_linear_local.m:669
            Xgrid_vector=reshape(Xgrid,[],1)
# Trainmatlab.v.0/aps_powerlaw_linear_local.m:670
            Ygrid_vector=reshape(Ygrid,[],1)
# Trainmatlab.v.0/aps_powerlaw_linear_local.m:671
            X_points=repmat(Xgrid_vector,1,n_windows)
# Trainmatlab.v.0/aps_powerlaw_linear_local.m:674
            Y_points=repmat(Ygrid_vector,1,n_windows)
# Trainmatlab.v.0/aps_powerlaw_linear_local.m:675
            X_windows=repmat(window_xy[:,1].T,length(Ygrid_vector),1)
# Trainmatlab.v.0/aps_powerlaw_linear_local.m:676
            Y_windows=repmat(window_xy[:,2].T,length(Ygrid_vector),1)
# Trainmatlab.v.0/aps_powerlaw_linear_local.m:677
            Distance_grid=sqrt((X_points - X_windows) ** 2 + (Y_points - Y_windows) ** 2)
# Trainmatlab.v.0/aps_powerlaw_linear_local.m:678
            clear('X_points')
            clear('Y_points')
            clear('X_windows')
            clear('Y_windows')
            fprintf('Checking if there are hard ridges \\n')
            if sum(hard_ridge_flag) > 0:
                #         keyboard
#         ix_hard_ridges = find(hard_ridge_flag==1);
#         xy_hard_ridge = [];
#         for kkk=1:sum(hard_ridge_flag)
#             ix_hard_ridge = ix_hard_ridges(kkk);
# 
#             # getting the coordinates of the hard ridge
#             xy_hard_ridge_temp = xy_rotatelocal{ix_hard_ridges(kkk)}-repmat(xy_local_regrid,size(xy_rotatelocal{ix_hard_ridges(kkk)},1),1);
#             xy_hard_ridge = [xy_hard_ridge ; xy_hard_ridge_temp];
#             clear xy_hard_ridge_temp
#             if kkk+1<=sum(hard_ridge_flag)
#                 xy_hard_ridge = [xy_hard_ridge; NaN NaN];
#             end
#             
#         end
#            
#         # loopign for every grid point
#         tic
#         for zz=1:length(Ygrid_vector)
# 
#             for kkkk=1:length(window_xy)
# 
#                 [x0,y0] = intersections(xy_hard_ridge(:,1),xy_hard_ridge(:,2),[window_xy(kkkk,1);Xgrid_vector(zz)],[window_xy(kkkk,2);Ygrid_vector(zz)],'robust');
#                 
#                 if ~isempty(x0)
#                     
#                     Distance_grid(zz,kkkk)=NaN;
#                 end
#                 clear xo;clear yo
# 
#                 #INTERSECTIONS Intersections of curves.
#                 #   Computes the (x,y) locations where two curves intersect.  The curves
#                 #   can be broken with NaNs or have vertical segments.
#                 #
#                 # Example:
#                 #   [X0,Y0] = intersections(X1,Y1,X2,Y2,ROBUST);
#                 #
#                 # where X1 and Y1 are equal-length vectors of at least two points and
#                 # represent curve 1.  Similarly, X2 and Y2 represent curve 2.
#                 # X0 and Y0 are column vectors containing the points at which the two
#                 # curves intersect.
#             end
#         end
#         toc
                # see if there are patches that are separated by windows.
                ix_hard_ridge_edges=matrix_patches_mean == 10000
# Trainmatlab.v.0/aps_powerlaw_linear_local.m:729
                X_hard_ridge_edge=Xmesh_patch_regions[ix_hard_ridge_edges]
# Trainmatlab.v.0/aps_powerlaw_linear_local.m:730
                Y_hard_ridge_edge=Ymesh_patch_regions[ix_hard_ridge_edges]
# Trainmatlab.v.0/aps_powerlaw_linear_local.m:731
                for kk in arange(1,length(Ygrid_vector)).reshape(-1):
                    for kkk in arange(1,n_windows).reshape(-1):
                        P1=matlabarray(cat(Xgrid_vector[kk,:],Ygrid_vector[kk,:]))
# Trainmatlab.v.0/aps_powerlaw_linear_local.m:739
                        P2=window_xy[kkk,:]
# Trainmatlab.v.0/aps_powerlaw_linear_local.m:740
                        ax=(P2[1,2] - P1[1,2]) / (P2[1,1] - P1[1,1])
# Trainmatlab.v.0/aps_powerlaw_linear_local.m:742
                        bx=dot(dot(- 1,ax),P1[1,1]) + P1[1,2]
# Trainmatlab.v.0/aps_powerlaw_linear_local.m:743
                        ay=(P2[1,1] - P1[1,1]) / (P2[1,2] - P1[1,2])
# Trainmatlab.v.0/aps_powerlaw_linear_local.m:744
                        by=dot(dot(- 1,ay),P1[1,2]) + P1[1,1]
# Trainmatlab.v.0/aps_powerlaw_linear_local.m:745
                        x_sampling=matlabarray(cat(arange(min(cat(P1[1],P2[1])),max(cat(P1[1],P2[1])))))
# Trainmatlab.v.0/aps_powerlaw_linear_local.m:746
                        y_sampling=matlabarray(cat(arange(min(cat(P1[2],P2[2])),max(cat(P1[2],P2[2])))))
# Trainmatlab.v.0/aps_powerlaw_linear_local.m:747
                        y_line=(dot(ax,x_sampling) + bx)
# Trainmatlab.v.0/aps_powerlaw_linear_local.m:748
                        x_line=(dot(ay,y_sampling) + by)
# Trainmatlab.v.0/aps_powerlaw_linear_local.m:749
                        ix_temp=(X_hard_ridge_edge >= logical_and(min(cat(P1[1],P2[1])) - 2,X_hard_ridge_edge) <= logical_and(max(cat(P1[1],P2[1])) + 2,Y_hard_ridge_edge) >= logical_and(min(cat(P1[2],P2[2])) - 2,Y_hard_ridge_edge) <= max(cat(P1[2],P2[2])) + 2)
# Trainmatlab.v.0/aps_powerlaw_linear_local.m:752
                        if sum(ix_temp) > 0:
                            # computing the residuals between the line and the ridge location
                    # x-direction sampling
                            y_line_res=reshape(repmat(y_line,length(Y_hard_ridge_edge[ix_temp]),1) - repmat(Y_hard_ridge_edge[ix_temp],1,length(y_line)),[],1)
# Trainmatlab.v.0/aps_powerlaw_linear_local.m:757
                            x_sampling_res=reshape(repmat(x_sampling,length(X_hard_ridge_edge[ix_temp]),1) - repmat(X_hard_ridge_edge[ix_temp],1,length(x_sampling)),[],1)
# Trainmatlab.v.0/aps_powerlaw_linear_local.m:758
                            XY_line_res=(abs(cat(x_sampling_res,y_line_res)))
# Trainmatlab.v.0/aps_powerlaw_linear_local.m:759
                            x_line_res=reshape(repmat(x_line,length(X_hard_ridge_edge[ix_temp]),1) - repmat(X_hard_ridge_edge[ix_temp],1,length(x_line)),[],1)
# Trainmatlab.v.0/aps_powerlaw_linear_local.m:761
                            y_sampling_res=reshape(repmat(y_sampling,length(Y_hard_ridge_edge[ix_temp]),1) - repmat(Y_hard_ridge_edge[ix_temp],1,length(y_sampling)),[],1)
# Trainmatlab.v.0/aps_powerlaw_linear_local.m:762
                            YX_line_res=(abs(cat(x_line_res,y_sampling_res)))
# Trainmatlab.v.0/aps_powerlaw_linear_local.m:763
                            ix_ridge=sum(XY_line_res[:,1] < logical_and(1,XY_line_res[:,2]) < 1)
# Trainmatlab.v.0/aps_powerlaw_linear_local.m:765
                            ix_ridge=ix_ridge + sum(YX_line_res[:,1] < logical_and(1,YX_line_res[:,2]) < 1)
# Trainmatlab.v.0/aps_powerlaw_linear_local.m:766
                        else:
                            ix_ridge=0
# Trainmatlab.v.0/aps_powerlaw_linear_local.m:768
                        if ix_ridge > 0:
                            Distance_grid[kk,kkk]=NaN
# Trainmatlab.v.0/aps_powerlaw_linear_local.m:774
                            #                 plot(X_hard_ridge_edge,Y_hard_ridge_edge,'k.')
    #                 hold on
    #                 plot([P1(1) P2(1)],[P1(2) P2(2)],'r.-')
    #                 hold on
    #                 plot(X_hard_ridge_edge(ix_temp),Y_hard_ridge_edge(ix_temp),'go')
    # 
    #                 
    #                 axis equal
    #                 axis tight
    #                 keyboard
                fprintf('Computing the regional weights, Done ... \\n')
                # find those poitns that were on the ridge edge and did not have a
        # window allocated. Set it to the closed window
                ix=find(sum(isnan(Distance_grid),2) == n_windows)
# Trainmatlab.v.0/aps_powerlaw_linear_local.m:794
                if logical_not(isempty(ix)):
                    # Computing weights based on distance from the points to the windows centers
                    X_points=repmat(Xgrid_vector[ix,1],1,n_windows)
# Trainmatlab.v.0/aps_powerlaw_linear_local.m:797
                    Y_points=repmat(Ygrid_vector[ix,1],1,n_windows)
# Trainmatlab.v.0/aps_powerlaw_linear_local.m:798
                    X_windows=repmat(window_xy[:,1].T,length(ix),1)
# Trainmatlab.v.0/aps_powerlaw_linear_local.m:799
                    Y_windows=repmat(window_xy[:,2].T,length(ix),1)
# Trainmatlab.v.0/aps_powerlaw_linear_local.m:800
                    Distance_temp=sqrt((X_points - X_windows) ** 2 + (Y_points - Y_windows) ** 2)
# Trainmatlab.v.0/aps_powerlaw_linear_local.m:801
                    clear('X_points')
                    clear('Y_points')
                    clear('X_windows')
                    clear('Y_windows')
                    Distance_temp_min=(min(Distance_temp.T)).T
# Trainmatlab.v.0/aps_powerlaw_linear_local.m:804
                    for kkk in arange(1,length(Distance_temp_min)).reshape(-1):
                        ix_closest_window=find(Distance_temp_min[kkk] == Distance_temp[kkk,:])
# Trainmatlab.v.0/aps_powerlaw_linear_local.m:806
                        Distance_grid[ix[kkk],ix_closest_window]=Distance_temp_min[kkk]
# Trainmatlab.v.0/aps_powerlaw_linear_local.m:807
                if flag_figure_checks == 1:
                    for kkk in arange(1,n_windows).reshape(-1):
                        figure('name',cat('Window ',num2str(kkk),' distance to points (NaN is no influence due to ridge blockage)'))
                        scatter3(Xgrid_vector[:,1],Ygrid_vector[:,1],Distance_grid[:,kkk],3,Distance_grid[:,kkk],'filled')
                        view(0,90)
                        axis('equal')
                        axis('tight')
                        title(cat('Window ',num2str(kkk),' distance to points (NaN is no influence due to ridge blockage)'))
                        xlim(cat(min(xy_local[:,1]),max(xy_local[:,1])))
                        ylim(cat(min(xy_local[:,2]),max(xy_local[:,2])))
                #################
            # # #         
# # #         
# # #         
# # #         # see if there are patches that are separated by windows.
# # #         ix_hard_ridge_edges = matrix_patches_mean==10000;
# # #         X_hard_ridge_edge = Xmesh_patch_regions(ix_hard_ridge_edges);
# # #         Y_hard_ridge_edge = Ymesh_patch_regions(ix_hard_ridge_edges);
# # # 
# # # 
# # #         fprintf('Computing the regional weights, this can take some time ... \n')
# # #         for kk=1:n_points
# # #             for kkk=1:n_windows
# # # 
# # #                 P1=xy_local(kk,:);
# # #                 P2= window_xy(kkk,:);
# # #                 # define equation line
# # #                 ax = (P2(1,2)-P1(1,2))/(P2(1,1)-P1(1,1));
# # #                 bx = -1*ax*P1(1,1)+P1(1,2);
# # #                 ay =  (P2(1,1)-P1(1,1))/(P2(1,2)-P1(1,2));
# # #                 by = -1*ay*P1(1,2)+P1(1,1);
# # #                 x_sampling = [min([P1(1) P2(1)]) : max([P1(1) P2(1)])];
# # #                 y_sampling = [min([P1(2) P2(2)]) : max([P1(2) P2(2)])];
# # #                 y_line = (ax*x_sampling+bx);
# # #                 x_line = (ay*y_sampling+by);
# # # 
# # #                 # limit the number of ridge intersections by a bounding box the two line points
# # #                 ix_temp =  (X_hard_ridge_edge >= min([P1(1) P2(1)])-2 & X_hard_ridge_edge <= max([P1(1) P2(1)])+2 & Y_hard_ridge_edge>= min([P1(2) P2(2)])-2 & Y_hard_ridge_edge<= max([P1(2) P2(2)])+2);
# # # 
# # #                  if sum(ix_temp)>0
# # #                     # computing the residuals between the line and the ridge location
# # #                     # x-direction sampling
# # #                     y_line_res = reshape(repmat(y_line,length(Y_hard_ridge_edge(ix_temp)),1) - repmat(Y_hard_ridge_edge(ix_temp),1,length(y_line)),[],1);
# # #                     x_sampling_res = reshape(repmat(x_sampling,length(X_hard_ridge_edge(ix_temp)),1) - repmat(X_hard_ridge_edge(ix_temp),1,length(x_sampling)),[],1);
# # #                     XY_line_res = (abs([x_sampling_res y_line_res ]));
# # #                     # x-direction sampling
# # #                     x_line_res = reshape(repmat(x_line,length(X_hard_ridge_edge(ix_temp)),1) - repmat(X_hard_ridge_edge(ix_temp),1,length(x_line)),[],1);
# # #                     y_sampling_res = reshape(repmat(y_sampling,length(Y_hard_ridge_edge(ix_temp)),1) - repmat(Y_hard_ridge_edge(ix_temp),1,length(y_sampling)),[],1);
# # #                     YX_line_res = (abs([x_line_res y_sampling_res ]));
# # # 
# # #                     ix_ridge = sum(XY_line_res(:,1)<1 & XY_line_res(:,2)<1 );
# # #                     ix_ridge = ix_ridge + sum(YX_line_res(:,1)<1 & YX_line_res(:,2)<1);
# # #                 else
# # #                     ix_ridge = 0; 
# # #                  end
# # # 
# # # 
# # # 
# # #                 if ix_ridge>0
# # #                     Distance(kk,kkk)=NaN;
# # #     #                 figure
# # #     #                 plot(X_hard_ridge_edge,Y_hard_ridge_edge,'k.')
# # #     #                 hold on
# # #     #                 plot([P1(1) P2(1)],[P1(2) P2(2)],'r.-')
# # #     #                 hold on
# # #     #                 plot(X_hard_ridge_edge(ix_temp),Y_hard_ridge_edge(ix_temp),'go')
# # #     # 
# # #     #                 
# # #     #                 axis equal
# # #     #                 axis tight
# # #     #                 keyboard
# # #                 end         
# # #             end
# # #         end
# # #         fprintf('Computing the regional weights, Done ... \n')
# # # 
# # #     end     
# # #     
# # #     # find those poitns that were on the ridge edge and did not have a
# # #     # window allocated. Set it to the closed window
# # #     ix = find(sum(isnan(Distance),2)==n_windows);
# # #     if ~isempty(ix)
# # #         # Computing weights based on distance from the points to the windows centers
# # #         X_points = repmat( xy_local(ix,1),1,n_windows);
# # #         Y_points = repmat(xy_local(ix,2),1,n_windows);
# # #         X_windows = repmat(window_xy(:,1)',length(ix),1);
# # #         Y_windows = repmat(window_xy(:,2)',length(ix),1);
# # #         Distance_temp = sqrt((X_points-X_windows).^2+(Y_points-Y_windows).^2);
# # #         clear X_points;clear Y_points;clear X_windows;clear Y_windows
# # # 
# # #         Distance_temp_min = (min(Distance_temp'))';
# # #         for kkk=1:length(Distance_temp_min)
# # #             ix_closest_window = find(Distance_temp_min(kkk)==Distance_temp(kkk,:));
# # #             Distance(ix(kkk),ix_closest_window)=Distance_temp_min(kkk);
# # #         end
# # #     end
# # #     
# # # 
# # #     if flag_figure_checks==1
# # #         for kkk=1:n_windows
# # #             figure('name',['Window ' num2str(kkk) ' distance to points (NaN is no influence due to ridge blockage)'])
# # #             scatter3(xy_local(:,1),xy_local (:,2),Distance(:,kkk),3,Distance(:,kkk),'filled')
# # #             view(0,90)
# # #             axis equal
# # #             axis tight
# # #             title(['Window ' num2str(kkk) ' distance to points (NaN is no influence due to ridge blockage)'] )
# # #             xlim([min(xy_local(:,1)) max(xy_local(:,1))]);
# # #             ylim([min(xy_local(:,2)) max(xy_local(:,2))]);
# # #         end
# # #     end
            # Compute the gaussian weight based on distance
            w_d=normpdf(Distance_grid,0,patch_c2c)
# Trainmatlab.v.0/aps_powerlaw_linear_local.m:947
            # Put the weight of the patches excluded due to mountains to zero.
            w_d[isnan(w_d)]=0
# Trainmatlab.v.0/aps_powerlaw_linear_local.m:950
            window_xy_extra=matlabarray([])
# Trainmatlab.v.0/aps_powerlaw_linear_local.m:953
            ix_edges_window=matlabarray([])
# Trainmatlab.v.0/aps_powerlaw_linear_local.m:954
            ridges_flag='y'
# Trainmatlab.v.0/aps_powerlaw_linear_local.m:955
            XYgrid_vector=matlabarray(cat(Xgrid_vector,Ygrid_vector))
# Trainmatlab.v.0/aps_powerlaw_linear_local.m:956
            n_grid_average=ceil(dot(2,patch_c2c) / grid_resolution)
# Trainmatlab.v.0/aps_powerlaw_linear_local.m:957
            iterate.window_ix = copy(window_ix)
# Trainmatlab.v.0/aps_powerlaw_linear_local.m:960
            iterate.window_xy = copy(window_xy)
# Trainmatlab.v.0/aps_powerlaw_linear_local.m:961
            iterate.window_xy_extra = copy(window_xy_extra)
# Trainmatlab.v.0/aps_powerlaw_linear_local.m:962
            iterate.ix_edges_window = copy(ix_edges_window)
# Trainmatlab.v.0/aps_powerlaw_linear_local.m:963
            iterate.w_d = copy(w_d)
# Trainmatlab.v.0/aps_powerlaw_linear_local.m:964
            iterate.ridges_flag = copy(ridges_flag)
# Trainmatlab.v.0/aps_powerlaw_linear_local.m:965
            iterate.patch_regions = copy(patch_regions)
# Trainmatlab.v.0/aps_powerlaw_linear_local.m:966
            iterate.Ymesh_patch_regions = copy(Ymesh_patch_regions)
# Trainmatlab.v.0/aps_powerlaw_linear_local.m:967
            iterate.Xmesh_patch_regions = copy(Xmesh_patch_regions)
# Trainmatlab.v.0/aps_powerlaw_linear_local.m:968
            iterate.XYgrid_vector = copy(XYgrid_vector)
# Trainmatlab.v.0/aps_powerlaw_linear_local.m:969
            iterate.grid_resolution = copy(grid_resolution)
# Trainmatlab.v.0/aps_powerlaw_linear_local.m:970
            iterate.n_grid_average = copy(n_grid_average)
# Trainmatlab.v.0/aps_powerlaw_linear_local.m:971
            iterate.dimensions_grid = copy(dimensions_grid)
# Trainmatlab.v.0/aps_powerlaw_linear_local.m:972
            clear('Xgrid_vector')
            clear('Ygrid_vector')
        else:
            # Loading the existing data
    # When using the ridges approach some of the fields are empty.
    # All patches wil have an equal weight in the ridges approach
    # All points within a patch will have the patche value. 
    # But a mean filter will be used to smooth out the data
            window_ix=iterate.window_ix
# Trainmatlab.v.0/aps_powerlaw_linear_local.m:981
            window_xy=iterate.window_xy
# Trainmatlab.v.0/aps_powerlaw_linear_local.m:982
            window_xy_extra=iterate.window_xy_extra
# Trainmatlab.v.0/aps_powerlaw_linear_local.m:983
            ix_edges_window=iterate.ix_edges_window
# Trainmatlab.v.0/aps_powerlaw_linear_local.m:984
            w_d=iterate.w_d
# Trainmatlab.v.0/aps_powerlaw_linear_local.m:985
            ridges_flag=iterate.ridges_flag
# Trainmatlab.v.0/aps_powerlaw_linear_local.m:986
            patch_regions=iterate.patch_regions
# Trainmatlab.v.0/aps_powerlaw_linear_local.m:987
            Ymesh_patch_regions=iterate.Ymesh_patch_regions
# Trainmatlab.v.0/aps_powerlaw_linear_local.m:988
            Xmesh_patch_regions=iterate.Xmesh_patch_regions
# Trainmatlab.v.0/aps_powerlaw_linear_local.m:989
            if strcmpi(powerlaw_ridge_constraint,'y'):
                XYgrid_vector=iterate.XYgrid_vector
# Trainmatlab.v.0/aps_powerlaw_linear_local.m:992
                grid_resolution=iterate.grid_resolution
# Trainmatlab.v.0/aps_powerlaw_linear_local.m:993
                n_grid_average=iterate.n_grid_average
# Trainmatlab.v.0/aps_powerlaw_linear_local.m:994
                dimensions_grid=iterate.dimensions_grid
# Trainmatlab.v.0/aps_powerlaw_linear_local.m:995
    
    clear('kk')
    clear('k')
    ## Estimating the linear relation for each window.
# do it for each frequency band and keep only those which are consistent
    n_windows=length(window_ix)
# Trainmatlab.v.0/aps_powerlaw_linear_local.m:1005
    n_datasets=size(data_local1,2)
# Trainmatlab.v.0/aps_powerlaw_linear_local.m:1006
    # initialisation of the variables
    slope_window=NaN(cat(n_windows,1))
# Trainmatlab.v.0/aps_powerlaw_linear_local.m:1010
    # looping over all the windows
    for k in arange(1,n_windows).reshape(-1):
        if n_windows == 1 and strcmp(plane_mode,'y'):
            ix=window_ix[k]
# Trainmatlab.v.0/aps_powerlaw_linear_local.m:1014
            n_points_window=length(ix)
# Trainmatlab.v.0/aps_powerlaw_linear_local.m:1016
            for kk in arange(1,n_datasets).reshape(-1):
                if sum(isnan(data_local1[ix,kk])) > 1:
                    fprintf('Modify the inversion such no nans are pressent, this is for crop out region! \\n')
                    keyboard
                scaling=1.0 / mean(abs(data_local1[ix,kk]))
# Trainmatlab.v.0/aps_powerlaw_linear_local.m:1028
                A=matlabarray(cat(multiply(multiply(data_local1[ix,kk],scaling),xy_local[:,1]),multiply(multiply(data_local1[ix,kk],scaling),xy_local[:,2]),multiply(data_local1[ix,kk],scaling),ones(cat(n_points_window,1))))
# Trainmatlab.v.0/aps_powerlaw_linear_local.m:1030
                coeff=lscov(A,data_local2[ix,kk])
# Trainmatlab.v.0/aps_powerlaw_linear_local.m:1032
                slope_window_band[kk,1]=multiply(coeff[1],scaling)
# Trainmatlab.v.0/aps_powerlaw_linear_local.m:1034
                slope_window_band[kk,2]=multiply(coeff[2],scaling)
# Trainmatlab.v.0/aps_powerlaw_linear_local.m:1035
                slope_window_band[kk,3]=multiply(coeff[3],scaling)
# Trainmatlab.v.0/aps_powerlaw_linear_local.m:1036
                offset_window_band[kk]=coeff[4]
# Trainmatlab.v.0/aps_powerlaw_linear_local.m:1037
                Q_coeff=inv(dot(A.T,A))
# Trainmatlab.v.0/aps_powerlaw_linear_local.m:1040
                slope_window_band_std[kk,1]=multiply(sqrt(Q_coeff[1,1]),scaling)
# Trainmatlab.v.0/aps_powerlaw_linear_local.m:1042
                slope_window_band_std[kk,2]=multiply(sqrt(Q_coeff[2,2]),scaling)
# Trainmatlab.v.0/aps_powerlaw_linear_local.m:1043
                slope_window_band_std[kk,3]=multiply(sqrt(Q_coeff[3,3]),scaling)
# Trainmatlab.v.0/aps_powerlaw_linear_local.m:1044
                offset_window_band_std[kk]=sqrt(Q_coeff[2,2])
# Trainmatlab.v.0/aps_powerlaw_linear_local.m:1045
            clear('kk')
            # Checking if the troposheric delay needs to be computed for each bandfilter
            if strcmp(powerlaw_all_bands,'y'):
                # keep the information of all the band stored for latter on
                slope_window_band_matrix[:,k]=slope_window_band
# Trainmatlab.v.0/aps_powerlaw_linear_local.m:1052
                slope_window_band_std_matrix[:,k]=slope_window_band_std
# Trainmatlab.v.0/aps_powerlaw_linear_local.m:1053
            # Estimating the window slope value by the weighted mean of the consistent bands.
        # deformation contaminated bands are rejected by outlier testing.
        # outlier rejection based on the bands for each of the plane coefficients
            slope_mean_x,slope_window_std_mean_x,obs_kept=w_test_mean(slope_window_band[:,1],slope_window_band_std[:,1],[],nargout=3)
# Trainmatlab.v.0/aps_powerlaw_linear_local.m:1059
            slope_window[k,1]=slope_mean_x
# Trainmatlab.v.0/aps_powerlaw_linear_local.m:1060
            slope_window_std[k,1]=slope_window_std_mean_x
# Trainmatlab.v.0/aps_powerlaw_linear_local.m:1061
            slope_mean_y,slope_window_std_mean_y,obs_kept=w_test_mean(slope_window_band[:,2],slope_window_band_std[:,2],[],nargout=3)
# Trainmatlab.v.0/aps_powerlaw_linear_local.m:1062
            slope_window[k,2]=slope_mean_y
# Trainmatlab.v.0/aps_powerlaw_linear_local.m:1063
            slope_window_std[k,2]=slope_window_std_mean_y
# Trainmatlab.v.0/aps_powerlaw_linear_local.m:1064
            slope_mean,slope_window_std_mean,obs_kept=w_test_mean(slope_window_band[:,3],slope_window_band_std[:,3],[],nargout=3)
# Trainmatlab.v.0/aps_powerlaw_linear_local.m:1065
            slope_window[k,3]=slope_mean
# Trainmatlab.v.0/aps_powerlaw_linear_local.m:1066
            slope_window_std[k,3]=slope_window_std_mean
# Trainmatlab.v.0/aps_powerlaw_linear_local.m:1067
            clear('slope_mean_x')
            clear('slope_window_std_mean_x')
            clear('obs_kept')
            clear('slope_mean_y')
            clear('slope_window_std_mean_y')
            clear('slope_mean')
            clear('slope_window_std_mean')
        else:
            ix_original=window_ix[k]
# Trainmatlab.v.0/aps_powerlaw_linear_local.m:1074
            n_points_window_original=length(ix_original)
# Trainmatlab.v.0/aps_powerlaw_linear_local.m:1076
            # initialisation of the variables
            slope_window_band=NaN(cat(n_datasets,1))
# Trainmatlab.v.0/aps_powerlaw_linear_local.m:1082
            slope_window_band_std=NaN(cat(n_datasets,1))
# Trainmatlab.v.0/aps_powerlaw_linear_local.m:1083
            slope_window_band_std_bootstrap=NaN(cat(n_datasets,1))
# Trainmatlab.v.0/aps_powerlaw_linear_local.m:1084
            slope_window_band_std_error_prop=NaN(cat(n_datasets,1))
# Trainmatlab.v.0/aps_powerlaw_linear_local.m:1085
            offset_window_band=NaN(cat(n_datasets,1))
# Trainmatlab.v.0/aps_powerlaw_linear_local.m:1086
            offset_window_band_std=NaN(cat(n_datasets,1))
# Trainmatlab.v.0/aps_powerlaw_linear_local.m:1087
            for kk in arange(1,n_datasets).reshape(-1):
                # removing the nan values for each data set, which could be
            # different for each interferogram, or could be a mutially
            # cropped region
                ix_bad=((isnan(data_local1[ix_original,kk]) + isnan(data_local2[ix_original,kk])) >= 1)
# Trainmatlab.v.0/aps_powerlaw_linear_local.m:1095
                #             ix = ix_original(~isnan(data_local1(ix_original,kk)));
                ix=ix_original[logical_not(ix_bad)]
# Trainmatlab.v.0/aps_powerlaw_linear_local.m:1097
                n_points_window=length(ix)
# Trainmatlab.v.0/aps_powerlaw_linear_local.m:1098
                if n_points_window >= 10:
                    # use mean to renormalize such the matrix does not become rank
                # deficient for extreme values
                    scaling=1.0 / mean(abs(data_local1[ix,kk]))
# Trainmatlab.v.0/aps_powerlaw_linear_local.m:1103
                    A=matlabarray(cat(multiply(data_local1[ix,kk],scaling),ones(cat(n_points_window,1))))
# Trainmatlab.v.0/aps_powerlaw_linear_local.m:1107
                    coeff=lscov(A,data_local2[ix,kk])
# Trainmatlab.v.0/aps_powerlaw_linear_local.m:1109
                    if sum(isnan(coeff)) > 0:
                        keyboard
                    # correct for the introduced scaling
                    slope_window_band[kk]=multiply(coeff[1],scaling)
# Trainmatlab.v.0/aps_powerlaw_linear_local.m:1115
                    offset_window_band[kk]=coeff[2]
# Trainmatlab.v.0/aps_powerlaw_linear_local.m:1116
                    clear('coeff')
                    # bootstrapping for error estimation
                    coeff_std,coeff_vector=aps_powerlaw_bootstrap(A,data_local2[ix,kk],n_boot_runs,nargout=2)
# Trainmatlab.v.0/aps_powerlaw_linear_local.m:1123
                    slope_window_band_std_bootstrap[kk]=multiply(coeff_std[1],scaling)
# Trainmatlab.v.0/aps_powerlaw_linear_local.m:1124
                    Q_coeff=inv(dot(A.T,A))
# Trainmatlab.v.0/aps_powerlaw_linear_local.m:1128
                    slope_window_band_std_error_prop[kk]=multiply(sqrt(Q_coeff[1,1]),scaling)
# Trainmatlab.v.0/aps_powerlaw_linear_local.m:1130
                    clear('Q_coeff')
                    clear('scaling','A','coeff')
                else:
                    # not enough points to estimate the relationship
                    slope_window_band_std_bootstrap[kk]=NaN
# Trainmatlab.v.0/aps_powerlaw_linear_local.m:1135
                    slope_window_band_std_error_prop[kk]=NaN
# Trainmatlab.v.0/aps_powerlaw_linear_local.m:1136
            clear('kk')
            clear('ix')
            # ifg you want to change the std you should do it here:
            if bootstrap_flag == 1:
                slope_window_band_std=copy(slope_window_band_std_bootstrap)
# Trainmatlab.v.0/aps_powerlaw_linear_local.m:1145
            else:
                slope_window_band_std=copy(slope_window_band_std_error_prop)
# Trainmatlab.v.0/aps_powerlaw_linear_local.m:1147
            # Checking if the troposheric delay needs to be computed for each bandfilter
            if strcmp(powerlaw_all_bands,'y'):
                # keep the information of all the band stored for latter on
                slope_window_band_matrix[:,k]=slope_window_band
# Trainmatlab.v.0/aps_powerlaw_linear_local.m:1153
                slope_window_band_std_matrix[:,k]=slope_window_band_std
# Trainmatlab.v.0/aps_powerlaw_linear_local.m:1154
            # Estimating the window slope value by the weighted mean of the consistent bands.
        # deformation contaminated bands are rejected by outlier testing.
            slope_mean,slope_window_std_mean,obs_kept=w_test_mean(slope_window_band,slope_window_band_std,[],nargout=3)
# Trainmatlab.v.0/aps_powerlaw_linear_local.m:1162
            slope_window[k,1]=slope_mean
# Trainmatlab.v.0/aps_powerlaw_linear_local.m:1163
            slope_window_std[k,1]=slope_window_std_mean
# Trainmatlab.v.0/aps_powerlaw_linear_local.m:1164
            if save_flag_outlier_windows == 1 and strcmpi(powerlaw_ridge_constraint,'n'):
                temp=cat(arange(1,n_datasets)).T
# Trainmatlab.v.0/aps_powerlaw_linear_local.m:1168
                edge_flag=find(k == ix_edges_window)
# Trainmatlab.v.0/aps_powerlaw_linear_local.m:1169
                if isempty(edge_flag) != 1:
                    str_extra=' (edge window)'
# Trainmatlab.v.0/aps_powerlaw_linear_local.m:1171
                else:
                    str_extra=''
# Trainmatlab.v.0/aps_powerlaw_linear_local.m:1173
                hfig=figure('name',cat('outlier rejection for window',num2str(k),str_extra))
# Trainmatlab.v.0/aps_powerlaw_linear_local.m:1175
                errorbar(slope_window_band,slope_window_band_std,'r.')
                hold('on')
                plot(temp[obs_kept],slope_window_band[obs_kept],'go')
                hold('on')
                plot(cat(1,n_datasets),cat(slope_mean,slope_mean),'k-')
                legend('obs','obs kept','mean estimate')
                if exist(save_path_outlier_window,'dir') != 7:
                    mkdir(save_path_outlier_window)
                title(cellarray([cat('window ',num2str(k)),' ']))
                xlabel(cat('Band 1 <----     -----> Band n'))
                if isempty(dimension_filter) != 1:
                    Ax1=copy(gca)
# Trainmatlab.v.0/aps_powerlaw_linear_local.m:1191
                    ylims=get(Ax1,'ylim')
# Trainmatlab.v.0/aps_powerlaw_linear_local.m:1192
                    ixplot=find(dimension_filter == 1)
# Trainmatlab.v.0/aps_powerlaw_linear_local.m:1194
                    if isempty(ixplot) != 1:
                        filter_transition=ixplot[1]
# Trainmatlab.v.0/aps_powerlaw_linear_local.m:1196
                        hold('on')
                        plot(cat(filter_transition,filter_transition),ylims,'k--')
                        legend('obs','obs kept','mean estimate','2D - 1D transition')
                    clear('ixplot')
                set(hfig,'PaperPositionMode','auto')
                print_(hfig,'-dpng','-r150',cat(save_path_outlier_window,filesep,'outlier_rej_window_',num2str(k)))
                close_(hfig)
                clear('temp')
                clear('hfig')
            clear('slope_mean')
            clear('obs_kept')
        fprintf(cat('Completed window ',num2str(k),' out of ',num2str(n_windows),'\\n'))
    
    perc_cons_K=copy(NaN)
# Trainmatlab.v.0/aps_powerlaw_linear_local.m:1215
    if n_windows == 1 and strcmp(plane_mode,'y'):
        # Checking if the troposheric delay needs to be computed for each bandfilter
        if strcmp(powerlaw_all_bands,'y'):
            for kk in arange(1,n_datasets).reshape(-1):
                if sum(isnan(slope_window_band_matrix[:,kk])) > 1:
                    fprintf('Modify the inversion such no nans are pressent, this is for crop out region! \\n')
                    keyboard
                # Compute slope for each PS point and the long wavelength tropospheric signal for each ifgs
                slope_band=dot(cat(xy_local,ones(cat(size(xy_local[:,1],1),1))),slope_window_band_matrix[:,kk])
# Trainmatlab.v.0/aps_powerlaw_linear_local.m:1230
                # compute delay from it
                ph_tropo_powerlaw_band[:,kk]=multiply(slope_band,(dot(h0[ifg_number],1000) - hgt) ** (alpha[ifg_number]))
# Trainmatlab.v.0/aps_powerlaw_linear_local.m:1233
                slope_local_band[:,kk]=slope_band
# Trainmatlab.v.0/aps_powerlaw_linear_local.m:1235
                clear('slope_band')
        else:
            ph_tropo_powerlaw_band=matlabarray([])
# Trainmatlab.v.0/aps_powerlaw_linear_local.m:1239
            slope_local_band=matlabarray([])
# Trainmatlab.v.0/aps_powerlaw_linear_local.m:1240
        # computing K at each PS location using the planar estimate
        slope_local=dot(cat(xy_local,ones(cat(size(xy_local[:,1],1),1))),slope_window.T)
# Trainmatlab.v.0/aps_powerlaw_linear_local.m:1243
        fprintf('Plane mode \\n')
    else:
        # Checking if the troposheric delay needs to be computed for each bandfilter
        if strcmp(powerlaw_all_bands,'y'):
            for kk in arange(1,n_datasets).reshape(-1):
                #             keyboard
                if sum(isnan(slope_window_band_std_matrix[kk,:])) > 1:
                    fprintf('Modify the inversion such no nans are pressent, this is for crop out region! \\n')
                    keyboard
                w_std=1.0 / slope_window_band_std_matrix[kk,:]
# Trainmatlab.v.0/aps_powerlaw_linear_local.m:1262
                w_std=repmat(w_std,size(w_d,1),1)
# Trainmatlab.v.0/aps_powerlaw_linear_local.m:1263
                w_std[(w_d == 0)]=0
# Trainmatlab.v.0/aps_powerlaw_linear_local.m:1264
                w_std=w_std / repmat(sum(w_std,2),1,n_windows)
# Trainmatlab.v.0/aps_powerlaw_linear_local.m:1265
                w=multiply(w_d,w_std)
# Trainmatlab.v.0/aps_powerlaw_linear_local.m:1268
                w=w / repmat(sum(w,2),1,n_windows)
# Trainmatlab.v.0/aps_powerlaw_linear_local.m:1269
                clear('w_std')
                if flag_figure_checks == 1 and strcmpi(powerlaw_ridge_constraint,'n'):
                    figure
                    scatter3(iterate.window_xy(arange(),1),iterate.window_xy(arange(),2),w[1000,:],25,w[1000,:],'filled')
                    view(0,90)
                    axis('equal')
                    axis('tight')
                    colorbar
                # For the ridges approach the data is kept on a regular
                # grid as at the end a smoothing is applied, after which
                # the interpolation to the ps lcoations is done.
                # For the windows approach the weights are at onces based
                # on those for the PS point locations
                if strcmpi(powerlaw_ridge_constraint,'y'):
                    slope_band_grid=dot(w,slope_window_band_matrix[kk,:].T)
# Trainmatlab.v.0/aps_powerlaw_linear_local.m:1288
                    temp_matrix=reshape(slope_band_grid,dimensions_grid[1],[])
# Trainmatlab.v.0/aps_powerlaw_linear_local.m:1290
                    H=fspecial('average',n_grid_average)
# Trainmatlab.v.0/aps_powerlaw_linear_local.m:1293
                    temp_matrix_mean=imfilter(temp_matrix,H,'replicate')
# Trainmatlab.v.0/aps_powerlaw_linear_local.m:1294
                    slope_band_grid_mean=reshape(temp_matrix_mean,[],1)
# Trainmatlab.v.0/aps_powerlaw_linear_local.m:1296
                    if flag_figure_checks == 1:
                        figure
                        scatter3(XYgrid_vector[:,1],XYgrid_vector[:,2],slope_band_grid,25,slope_band_grid,'filled')
                        view(0,90)
                        axis('equal')
                        axis('tight')
                        colorbar
                        figure
                        scatter3(XYgrid_vector[:,1],XYgrid_vector[:,2],slope_band_grid_mean,25,slope_band_grid_mean,'filled')
                        view(0,90)
                        axis('equal')
                        axis('tight')
                        colorbar
                    # perform smoothing operation
                    slope_band=griddata(XYgrid_vector[:,1],XYgrid_vector[:,2],slope_band_grid_mean,xy_local[:,1],xy_local[:,2],'linear')
# Trainmatlab.v.0/aps_powerlaw_linear_local.m:1315
                else:
                    # Compute slope, c for each PS point and the long wavelength tropospheric signal for each ifgs
                    slope_band=dot(w,slope_window_band_matrix[kk,:].T)
# Trainmatlab.v.0/aps_powerlaw_linear_local.m:1319
                clear('w')
                # compute delay from it
                ph_tropo_powerlaw_band[:,kk]=multiply(slope_band,(dot(h0[ifg_number],1000) - hgt) ** (alpha[ifg_number]))
# Trainmatlab.v.0/aps_powerlaw_linear_local.m:1324
                slope_local_band[:,kk]=slope_band
# Trainmatlab.v.0/aps_powerlaw_linear_local.m:1325
                clear('slope_band')
            clear('kk')
            clear('slope_window_band_std_matrix')
            clear('slope_window_band_matrix')
        else:
            ph_tropo_powerlaw_band=matlabarray([])
# Trainmatlab.v.0/aps_powerlaw_linear_local.m:1330
            slope_local_band=matlabarray([])
# Trainmatlab.v.0/aps_powerlaw_linear_local.m:1331
        #     keyboard
        ## Computing the delay based on the slope estimation from the good bands     
    # The weights based on the std of the windows
        w_std=1.0 / slope_window_std.T
# Trainmatlab.v.0/aps_powerlaw_linear_local.m:1338
        w_std=repmat(w_std,size(w_d,1),1)
# Trainmatlab.v.0/aps_powerlaw_linear_local.m:1339
        w_std[(w_d == 0)]=0
# Trainmatlab.v.0/aps_powerlaw_linear_local.m:1340
        w_std=w_std / repmat(sum(w_std,2),1,n_windows)
# Trainmatlab.v.0/aps_powerlaw_linear_local.m:1341
        w=multiply(w_d,w_std)
# Trainmatlab.v.0/aps_powerlaw_linear_local.m:1344
        w=w / repmat(sum(w,2),1,n_windows)
# Trainmatlab.v.0/aps_powerlaw_linear_local.m:1345
        clear('w_std')
        # Compute slope, c for each PS point and the long wavelength tropospheric signal for each ifgs
        if strcmpi(powerlaw_ridge_constraint,'y'):
            slope_grid=dot(w,slope_window)
# Trainmatlab.v.0/aps_powerlaw_linear_local.m:1350
            ix_pos=slope_window >= 0
# Trainmatlab.v.0/aps_powerlaw_linear_local.m:1352
            perc_cons_K=floor(dot((abs(sum(ix_pos) / length(slope_window) - 0.5) + 0.5),100))
# Trainmatlab.v.0/aps_powerlaw_linear_local.m:1353
            fprintf(cat(num2str(perc_cons_K),' perc of K are consistent in space \\n '))
            temp_matrix=reshape(slope_grid,dimensions_grid[1],[])
# Trainmatlab.v.0/aps_powerlaw_linear_local.m:1357
            H=fspecial('average',n_grid_average)
# Trainmatlab.v.0/aps_powerlaw_linear_local.m:1360
            temp_matrix_mean=imfilter(temp_matrix,H,'replicate')
# Trainmatlab.v.0/aps_powerlaw_linear_local.m:1361
            slope_grid_mean=reshape(temp_matrix_mean,[],1)
# Trainmatlab.v.0/aps_powerlaw_linear_local.m:1363
            slope_local=griddata(XYgrid_vector[:,1],XYgrid_vector[:,2],slope_grid_mean,xy_local[:,1],xy_local[:,2],'linear')
# Trainmatlab.v.0/aps_powerlaw_linear_local.m:1366
        else:
            perc_cons_K=copy(nan)
# Trainmatlab.v.0/aps_powerlaw_linear_local.m:1368
            slope_local=dot(w,slope_window)
# Trainmatlab.v.0/aps_powerlaw_linear_local.m:1369
        clear('w','w_d')
        if flag_figure_checks == 1 and debug_fig == 1:
            figure
            scatter3(xy_local[:,1],xy_local[:,2],slope_local,3,slope_local,'filled')
            hold('on')
            scatter3(window_xy[:,1],window_xy[:,2],slope_window,50,slope_window,'filled')
            view(0,90)
            axis('equal')
            axis('tight')
            xlimits=get(gca,'xlim')
# Trainmatlab.v.0/aps_powerlaw_linear_local.m:1382
            ylimits=get(gca,'ylim')
# Trainmatlab.v.0/aps_powerlaw_linear_local.m:1383
            title('slope')
            figure
            scatter3(window_xy[:,1],window_xy[:,2],slope_window_std,50,slope_window_std,'filled')
            view(0,90)
            axis('equal')
            axis('tight')
            title('std')
            set(gca,'xlim',xlimits)
            set(gca,'ylim',ylimits)
        fprintf('Regular mode \\n')
    
    # compute delay from it
    ph_tropo_powerlaw=multiply(slope_local,(dot(h0[ifg_number],1000) - hgt) ** (alpha[ifg_number]))
# Trainmatlab.v.0/aps_powerlaw_linear_local.m:1401
    if logical_not(isempty(ix_phase_nan_interferogram)):
        ph_tropo_powerlaw[ix_phase_nan_interferogram,:]=NaN
# Trainmatlab.v.0/aps_powerlaw_linear_local.m:1403
    