# Autogenerated with SMOP 
from smop.core import *
# Trainmatlab.v.0/intersections.m

    
@function
def intersections(x1=None,y1=None,x2=None,y2=None,robust=None,*args,**kwargs):
    varargin = intersections.varargin
    nargin = intersections.nargin

    #INTERSECTIONS Intersections of curves.
#   Computes the (x,y) locations where two curves intersect.  The curves
#   can be broken with NaNs or have vertical segments.
    
    # Example:
#   [X0,Y0] = intersections(X1,Y1,X2,Y2,ROBUST);
    
    # where X1 and Y1 are equal-length vectors of at least two points and
# represent curve 1.  Similarly, X2 and Y2 represent curve 2.
# X0 and Y0 are column vectors containing the points at which the two
# curves intersect.
    
    # ROBUST (optional) set to 1 or true means to use a slight variation of the
# algorithm that might return duplicates of some intersection points, and
# then remove those duplicates.  The default is true, but since the
# algorithm is slightly slower you can set it to false if you know that
# your curves don't intersect at any segment boundaries.  Also, the robust
# version properly handles parallel and overlapping segments.
    
    # The algorithm can return two additional vectors that indicate which
# segment pairs contain intersections and where they are:
    
    #   [X0,Y0,I,J] = intersections(X1,Y1,X2,Y2,ROBUST);
    
    # For each element of the vector I, I(k) = (segment number of (X1,Y1)) +
# (how far along this segment the intersection is).  For example, if I(k) =
# 45.25 then the intersection lies a quarter of the way between the line
# segment connecting (X1(45),Y1(45)) and (X1(46),Y1(46)).  Similarly for
# the vector J and the segments in (X2,Y2).
    
    # You can also get intersections of a curve with itself.  Simply pass in
# only one curve, i.e.,
    
    #   [X0,Y0] = intersections(X1,Y1,ROBUST);
    
    # where, as before, ROBUST is optional.
    
    # Version: 1.12, 27 January 2010
# Author:  Douglas M. Schwarz
# Email:   dmschwarz=ieee*org, dmschwarz=urgrad*rochester*edu
# Real_email = regexprep(Email,{'=','*'},{'@','.'})
    
    # Theory of operation:
    
    # Given two line segments, L1 and L2,
    
    #   L1 endpoints:  (x1(1),y1(1)) and (x1(2),y1(2))
#   L2 endpoints:  (x2(1),y2(1)) and (x2(2),y2(2))
    
    # we can write four equations with four unknowns and then solve them.  The
# four unknowns are t1, t2, x0 and y0, where (x0,y0) is the intersection of
# L1 and L2, t1 is the distance from the starting point of L1 to the
# intersection relative to the length of L1 and t2 is the distance from the
# starting point of L2 to the intersection relative to the length of L2.
    
    # So, the four equations are
    
    #    (x1(2) - x1(1))*t1 = x0 - x1(1)
#    (x2(2) - x2(1))*t2 = x0 - x2(1)
#    (y1(2) - y1(1))*t1 = y0 - y1(1)
#    (y2(2) - y2(1))*t2 = y0 - y2(1)
    
    # Rearranging and writing in matrix form,
    
    #  [x1(2)-x1(1)       0       -1   0;      [t1;      [-x1(1);
#        0       x2(2)-x2(1)  -1   0;   *   t2;   =   -x2(1);
#   y1(2)-y1(1)       0        0  -1;       x0;       -y1(1);
#        0       y2(2)-y2(1)   0  -1]       y0]       -y2(1)]
    
    # Let's call that A*T = B.  We can solve for T with T = A\B.
    
    # Once we have our solution we just have to look at t1 and t2 to determine
# whether L1 and L2 intersect.  If 0 <= t1 < 1 and 0 <= t2 < 1 then the two
# line segments cross and we can include (x0,y0) in the output.
    
    # In principle, we have to perform this computation on every pair of line
# segments in the input data.  This can be quite a large number of pairs so
# we will reduce it by doing a simple preliminary check to eliminate line
# segment pairs that could not possibly cross.  The check is to look at the
# smallest enclosing rectangles (with sides parallel to the axes) for each
# line segment pair and see if they overlap.  If they do then we have to
# compute t1 and t2 (via the A\B computation) to see if the line segments
# cross, but if they don't then the line segments cannot cross.  In a
# typical application, this technique will eliminate most of the potential
# line segment pairs.
    
    # Input checks.
    error(nargchk(2,5,nargin))
    # Adjustments when fewer than five arguments are supplied.
    if 2 == nargin:
        robust=copy(true)
# Trainmatlab.v.0/intersections.m:96
        x2=copy(x1)
# Trainmatlab.v.0/intersections.m:97
        y2=copy(y1)
# Trainmatlab.v.0/intersections.m:98
        self_intersect=copy(true)
# Trainmatlab.v.0/intersections.m:99
    else:
        if 3 == nargin:
            robust=copy(x2)
# Trainmatlab.v.0/intersections.m:101
            x2=copy(x1)
# Trainmatlab.v.0/intersections.m:102
            y2=copy(y1)
# Trainmatlab.v.0/intersections.m:103
            self_intersect=copy(true)
# Trainmatlab.v.0/intersections.m:104
        else:
            if 4 == nargin:
                robust=copy(true)
# Trainmatlab.v.0/intersections.m:106
                self_intersect=copy(false)
# Trainmatlab.v.0/intersections.m:107
            else:
                if 5 == nargin:
                    self_intersect=copy(false)
# Trainmatlab.v.0/intersections.m:109
    
    # x1 and y1 must be vectors with same number of points (at least 2).
    if sum(size(x1) > 1) != 1 or sum(size(y1) > 1) != 1 or length(x1) != length(y1):
        error('X1 and Y1 must be equal-length vectors of at least 2 points.')
    
    # x2 and y2 must be vectors with same number of points (at least 2).
    if sum(size(x2) > 1) != 1 or sum(size(y2) > 1) != 1 or length(x2) != length(y2):
        error('X2 and Y2 must be equal-length vectors of at least 2 points.')
    
    # Force all inputs to be column vectors.
    x1=ravel(x1)
# Trainmatlab.v.0/intersections.m:125
    y1=ravel(y1)
# Trainmatlab.v.0/intersections.m:126
    x2=ravel(x2)
# Trainmatlab.v.0/intersections.m:127
    y2=ravel(y2)
# Trainmatlab.v.0/intersections.m:128
    # Compute number of line segments in each curve and some differences we'll
# need later.
    n1=length(x1) - 1
# Trainmatlab.v.0/intersections.m:132
    n2=length(x2) - 1
# Trainmatlab.v.0/intersections.m:133
    xy1=matlabarray(cat(x1,y1))
# Trainmatlab.v.0/intersections.m:134
    xy2=matlabarray(cat(x2,y2))
# Trainmatlab.v.0/intersections.m:135
    dxy1=diff(xy1)
# Trainmatlab.v.0/intersections.m:136
    dxy2=diff(xy2)
# Trainmatlab.v.0/intersections.m:137
    # Determine the combinations of i and j where the rectangle enclosing the
# i'th line segment of curve 1 overlaps with the rectangle enclosing the
# j'th line segment of curve 2.
    i,j=find(repmat(min(x1[1:end() - 1],x1[2:end()]),1,n2) <= logical_and(repmat(max(x2[1:end() - 1],x2[2:end()]).T,n1,1),repmat(max(x1[1:end() - 1],x1[2:end()]),1,n2)) >= logical_and(repmat(min(x2[1:end() - 1],x2[2:end()]).T,n1,1),repmat(min(y1[1:end() - 1],y1[2:end()]),1,n2)) <= logical_and(repmat(max(y2[1:end() - 1],y2[2:end()]).T,n1,1),repmat(max(y1[1:end() - 1],y1[2:end()]),1,n2)) >= repmat(min(y2[1:end() - 1],y2[2:end()]).T,n1,1),nargout=2)
# Trainmatlab.v.0/intersections.m:142
    # Force i and j to be column vectors, even when their length is zero, i.e.,
# we want them to be 0-by-1 instead of 0-by-0.
    i=reshape(i,[],1)
# Trainmatlab.v.0/intersections.m:153
    j=reshape(j,[],1)
# Trainmatlab.v.0/intersections.m:154
    # Find segments pairs which have at least one vertex = NaN and remove them.
# This line is a fast way of finding such segment pairs.  We take
# advantage of the fact that NaNs propagate through calculations, in
# particular subtraction (in the calculation of dxy1 and dxy2, which we
# need anyway) and addition.
# At the same time we can remove redundant combinations of i and j in the
# case of finding intersections of a line with itself.
    if self_intersect:
        remove=logical_or(isnan(sum(dxy1[i,:] + dxy2[j,:],2)),j) <= i + 1
# Trainmatlab.v.0/intersections.m:164
    else:
        remove=isnan(sum(dxy1[i,:] + dxy2[j,:],2))
# Trainmatlab.v.0/intersections.m:166
    
    i[remove]=[]
# Trainmatlab.v.0/intersections.m:168
    j[remove]=[]
# Trainmatlab.v.0/intersections.m:169
    # Initialize matrices.  We'll put the T's and B's in matrices and use them
# one column at a time.  AA is a 3-D extension of A where we'll use one
# plane at a time.
    n=length(i)
# Trainmatlab.v.0/intersections.m:174
    T=zeros(4,n)
# Trainmatlab.v.0/intersections.m:175
    AA=zeros(4,4,n)
# Trainmatlab.v.0/intersections.m:176
    AA[cat(1,2),3,:]=- 1
# Trainmatlab.v.0/intersections.m:177
    AA[cat(3,4),4,:]=- 1
# Trainmatlab.v.0/intersections.m:178
    AA[cat(1,3),1,:]=dxy1[i,:].T
# Trainmatlab.v.0/intersections.m:179
    AA[cat(2,4),2,:]=dxy2[j,:].T
# Trainmatlab.v.0/intersections.m:180
    B=- cat(x1[i],x2[j],y1[i],y2[j]).T
# Trainmatlab.v.0/intersections.m:181
    # Loop through possibilities.  Trap singularity warning and then use
# lastwarn to see if that plane of AA is near singular.  Process any such
# segment pairs to determine if they are colinear (overlap) or merely
# parallel.  That test consists of checking to see if one of the endpoints
# of the curve 2 segment lies on the curve 1 segment.  This is done by
# checking the cross product
    
    #   (x1(2),y1(2)) - (x1(1),y1(1)) x (x2(2),y2(2)) - (x1(1),y1(1)).
    
    # If this is close to zero then the segments overlap.
    
    # If the robust option is false then we assume no two segment pairs are
# parallel and just go ahead and do the computation.  If A is ever singular
# a warning will appear.  This is faster and obviously you should use it
# only when you know you will never have overlapping or parallel segment
# pairs.
    
    if robust:
        overlap=false(n,1)
# Trainmatlab.v.0/intersections.m:201
        warning_state=warning('off','MATLAB:singularMatrix')
# Trainmatlab.v.0/intersections.m:202
        try:
            lastwarn('')
            for k in arange(1,n).reshape(-1):
                T[:,k]=numpy.linalg.solve(AA[:,:,k],B[:,k])
# Trainmatlab.v.0/intersections.m:207
                unused,last_warn=lastwarn
# Trainmatlab.v.0/intersections.m:208
                lastwarn('')
                if strcmp(last_warn,'MATLAB:singularMatrix'):
                    # Force in_range(k) to be false.
                    T[1,k]=NaN
# Trainmatlab.v.0/intersections.m:212
                    overlap[k]=rcond(cat([dxy1[i[k],:]],[xy2[j[k],:] - xy1[i[k],:]])) < eps
# Trainmatlab.v.0/intersections.m:214
            warning(warning_state)
        finally:
            pass
        # Find where t1 and t2 are between 0 and 1 and return the corresponding
	# x0 and y0 values.
        in_range=(T[1,:] >= logical_and(0,T[2,:]) >= logical_and(0,T[1,:]) <= logical_and(1,T[2,:]) <= 1).T
# Trainmatlab.v.0/intersections.m:224
        # intersection point that is at the center of the overlapping region.
        if any(overlap):
            ia=i[overlap]
# Trainmatlab.v.0/intersections.m:228
            ja=j[overlap]
# Trainmatlab.v.0/intersections.m:229
            T[3,overlap]=(max(min(x1[ia],x1[ia + 1]),min(x2[ja],x2[ja + 1])) + min(max(x1[ia],x1[ia + 1]),max(x2[ja],x2[ja + 1]))).T / 2
# Trainmatlab.v.0/intersections.m:231
            T[4,overlap]=(max(min(y1[ia],y1[ia + 1]),min(y2[ja],y2[ja + 1])) + min(max(y1[ia],y1[ia + 1]),max(y2[ja],y2[ja + 1]))).T / 2
# Trainmatlab.v.0/intersections.m:233
            selected=logical_or(in_range,overlap)
# Trainmatlab.v.0/intersections.m:235
        else:
            selected=copy(in_range)
# Trainmatlab.v.0/intersections.m:237
        xy0=T[3:4,selected].T
# Trainmatlab.v.0/intersections.m:239
        xy0,index=unique(xy0,'rows',nargout=2)
# Trainmatlab.v.0/intersections.m:242
        x0=xy0[:,1]
# Trainmatlab.v.0/intersections.m:243
        y0=xy0[:,2]
# Trainmatlab.v.0/intersections.m:244
        if nargout > 2:
            sel_index=find(selected)
# Trainmatlab.v.0/intersections.m:248
            sel=sel_index[index]
# Trainmatlab.v.0/intersections.m:249
            iout=i[sel] + T[1,sel].T
# Trainmatlab.v.0/intersections.m:250
            jout=j[sel] + T[2,sel].T
# Trainmatlab.v.0/intersections.m:251
    else:
        for k in arange(1,n).reshape(-1):
            L,U=lu(AA[:,:,k],nargout=2)
# Trainmatlab.v.0/intersections.m:255
            T[:,k]=numpy.linalg.solve(U,(numpy.linalg.solve(L,B[:,k])))
# Trainmatlab.v.0/intersections.m:256
        # Find where t1 and t2 are between 0 and 1 and return the corresponding
	# x0 and y0 values.
        in_range=(T[1,:] >= logical_and(0,T[2,:]) >= logical_and(0,T[1,:]) < logical_and(1,T[2,:]) < 1).T
# Trainmatlab.v.0/intersections.m:261
        x0=T[3,in_range].T
# Trainmatlab.v.0/intersections.m:262
        y0=T[4,in_range].T
# Trainmatlab.v.0/intersections.m:263
        if nargout > 2:
            iout=i[in_range] + T[1,in_range].T
# Trainmatlab.v.0/intersections.m:267
            jout=j[in_range] + T[2,in_range].T
# Trainmatlab.v.0/intersections.m:268
    
    # Plot the results (useful for debugging).
# plot(x1,y1,x2,y2,x0,y0,'ok');