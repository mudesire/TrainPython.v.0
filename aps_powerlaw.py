# Autogenerated with SMOP 
from smop.core import *
# matlab/aps_powerlaw.m

    
@function
def aps_powerlaw(start_step=None,end_step=None,save_path=None,*args,**kwargs):
    varargin = aps_powerlaw.varargin
    nargin = aps_powerlaw.nargin

    # aps_powerlaw(start_step,end_step)
# Program to compute the powerlaw tropsoheric delays. 
#   STEP 1 = Estimate powerlaw delay and maximum height from sounding data
#            (when this is available), or use defaults or user set values
#   STEP 2 = Rotate dataset to minimize interpolation effects, Powerlaw scaling and interpolate to regular grid 
#   STEP 3 = 1D/2D bandfiltering in the frequency domain and interpolate 
#            back to local grid 
#   STEP 4 = Spatial local estimation of the powerlaw scaling coefficient,
#            estimate final values from reliable frequency band, extrapolate 
#            to all point locations and compute powerlaw tropospheric delay. 
# 
#   To change the processing parameters use setparm_aps and getparm_aps
    
    # **** when using this estimation method please cite:
#       D.P.S. Bekaert, A.J. Hooper and T.J. Wright, A spatially-variable power-law tropospheric correction
# 	  	 technique for InSAR data, JGR, doi:10.1029/2014JB011558 *****
    
    # 
#     Copyright (C) 2015  Bekaert David - University of Leeds
#     Email: eedpsb@leeds.ac.uk or davidbekaert.com
# 
#     This program is free software; you can redistribute it and/or modify
#     it under the terms of the GNU General Public License as published by
#     the Free Software Foundation; either version 2 of the License, or
#     (at your option) any later version.
# 
#     This program is distributed in the hope that it will be useful,
#     but WITHOUT ANY WARRANTY; without even the implied warranty of
#     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#     GNU General Public License for more details.
# 
#     You should have received a copy of the GNU General Public License along
#     with this program; if not, write to the Free Software Foundation, Inc.,
#     51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
    
    # By David Bekaert - University of Leeds
    
    # modifications:
# 04/2013   DB:     Incorportate a parm_aps list with all the processing
#                   options and variables.
# 05/2013   DB:     Include powerlaw coefficient sensitivity analysis
# 05/2013   DB:     Allow for an interferogram based estimation
# 12/2013   DB:     Put the flag of ifg correction on prior to powerlaw computation
# 02/2014   DB:     Integrate the plotting with the running of the sounding data
# 02/2014   DB:     Include a mountain ridge code, user interaction needed
# 07/2014   DB:     Have the option to plot the ridges
# 07/2014   DB:     Include a cropping option
# 11/2014   DB:     Fix bug and include paper reference
# 03/2015   DB:     Ask for the reference technique in step 5
# 01/2016   DB:     Fix ll.lonlat, ph_uw, hgt for non-stamps data, replace
#                   save calls with aps_save, in case no -append flag is included
# 02/2016   DB:     Expand option 5 to plot with the unwrapped phase too.
    
    if nargin < 3:
        save_path=matlabarray(cat(pwd,filesep))
# matlab/aps_powerlaw.m:57
    
    currdir=copy(pwd)
# matlab/aps_powerlaw.m:60
    
    plot_flag=0
# matlab/aps_powerlaw.m:61
    hydro=1
# matlab/aps_powerlaw.m:62
    wet=1
# matlab/aps_powerlaw.m:63
    fprintf(cat('\\n********************************************************************************************************** \\n','D.P.S. Bekaert, A.J. Hooper and T.J. Wright,\\n','A spatially-variable power-law tropospheric correction technique for InSAR data, JGR,  doi:10.1029/2014JB011558\\n','**********************************************************************************************************\\n\\n'))
    ## PART 1: Define the powerlaw coefficents, from the user or by using sounding data.
    sounding_data=getparm_aps('sounding_data',1)
# matlab/aps_powerlaw.m:69
    stamps_processed=getparm_aps('stamps_processed',1)
# matlab/aps_powerlaw.m:70
    powerlaw_ridge_constraint=getparm_aps('powerlaw_ridge_constraint',1)
# matlab/aps_powerlaw.m:71
    if strcmp(stamps_processed,'y'):
        load('psver')
    else:
        psver=2
# matlab/aps_powerlaw.m:76
    
    # file names of the output data
    apsname=matlabarray(cat(save_path,filesep,'tca',num2str(psver),'.mat'))
# matlab/aps_powerlaw.m:80
    apssbname=matlabarray(cat(save_path,filesep,'tca_sb',num2str(psver),'.mat'))
# matlab/aps_powerlaw.m:81
    apsbandsname=matlabarray(cat(save_path,filesep,'tca_bands',num2str(psver),'.mat'))
# matlab/aps_powerlaw.m:82
    apsbandssbname=matlabarray(cat(save_path,filesep,'tca_bands_sb',num2str(psver),'.mat'))
# matlab/aps_powerlaw.m:83
    # saving part of the data in a subfolder
    save_path=matlabarray(cat(save_path,filesep,'aps_p'))
# matlab/aps_powerlaw.m:87
    if exist(save_path,'dir') != 7:
        mkdir(save_path)
    
    if start_step == 0 and strcmp(powerlaw_ridge_constraint,'y'):
        mountain_ridge=matlabarray([])
# matlab/aps_powerlaw.m:94
        if exist('tca_support.mat') == 2:
            load('tca_support.mat','powerlaw_ridges')
            if exist('powerlaw_ridges','var') == 1:
                mountain_ridge=powerlaw_ridges.mountain_ridge
# matlab/aps_powerlaw.m:98
        if isempty(mountain_ridge) == 1:
            str_repr='y'
# matlab/aps_powerlaw.m:102
            str_vis='n'
# matlab/aps_powerlaw.m:103
        # data has been computed before - reporcess? - visualize?
        if length(mountain_ridge) > 0:
            str_repr=''
# matlab/aps_powerlaw.m:108
            while strcmpi(str_repr,'y') != 1 and strcmpi(str_repr,'n') != 1:

                str_repr=input_(cat('Ridges have been defined before, reprocess the data? [y/n] \\n'),'s')
# matlab/aps_powerlaw.m:110

            # no reprocessing, do you want to visualize it?
            if strcmpi(str_repr,'n'):
                str_vis=''
# matlab/aps_powerlaw.m:115
                while strcmpi(str_vis,'y') != 1 and strcmpi(str_vis,'n') != 1:

                    str_vis=input_(cat('Do you want to visualize the data? [y/n] \\n'),'s')
# matlab/aps_powerlaw.m:117

            else:
                str_vis='n'
# matlab/aps_powerlaw.m:120
        if strcmpi(str_repr,'y'):
            mountain_ridge=aps_powerlaw_watershed
# matlab/aps_powerlaw.m:126
        if strcmpi(str_vis,'y'):
            aps_support_plot(1)
    
    if start_step == 1 and strcmp(sounding_data,'y'):
        fprintf('\\n\\nStep 1: Powerlaw coefficients from the sounding data\\n')
        # getting the variables from the parm_aps file
        look_angle=getparm_aps('look_angle',1)
# matlab/aps_powerlaw.m:138
        lambda_=getparm_aps('lambda',1)
# matlab/aps_powerlaw.m:139
        sounding_h0=getparm_aps('sounding_h0',1)
# matlab/aps_powerlaw.m:140
        sounding_h_alpha_thres=getparm_aps('sounding_h_alpha_thres',1)
# matlab/aps_powerlaw.m:141
        sounding_start_date=getparm_aps('sounding_start_date',1)
# matlab/aps_powerlaw.m:142
        sounding_end_date=getparm_aps('sounding_end_date',1)
# matlab/aps_powerlaw.m:143
        sounding_time_stamp=getparm_aps('sounding_time_stamp',1)
# matlab/aps_powerlaw.m:144
        sounding_dir=getparm_aps('sounding_dir',1)
# matlab/aps_powerlaw.m:145
        sounding_error_promp=getparm_aps('sounding_error_promp',1)
# matlab/aps_powerlaw.m:146
        sounding_sensitivity=getparm_aps('sounding_sensitivity',1)
# matlab/aps_powerlaw.m:147
        n_months=getparm_aps('sounding_months',1)
# matlab/aps_powerlaw.m:148
        time_stamp=getparm_aps('sounding_time_stamp',1)
# matlab/aps_powerlaw.m:149
        sounding_ifg_dates=getparm_aps('sounding_ifg_dates',1)
# matlab/aps_powerlaw.m:150
        ### needed, if not load exisitng file and plot results
        time_stamp_str=matlabarray([])
# matlab/aps_powerlaw.m:154
        for k in arange(1,size(time_stamp,1)).reshape(-1):
            if k > 1:
                time_stamp_str=matlabarray(cat(time_stamp_str,'_',time_stamp[k,:]))
# matlab/aps_powerlaw.m:157
            else:
                time_stamp_str=matlabarray(cat(time_stamp[k,:]))
# matlab/aps_powerlaw.m:159
        if strcmp(sounding_sensitivity,'y'):
            fprintf('Sensitivity analyses of sounding data \\n\\n')
            # check first if the output file is already exisiting otherwize
        # ask if it needs to be reprocessed or visualised.
            if strcmp(sounding_ifg_dates,'y'):
                fprintf('Coefficient estimation for each interferogram \\n\\n')
                if hydro == 1 and wet == 0:
                    save_name=matlabarray(cat(sounding_dir,filesep,'Powerlaw',filesep,'Powerlaw_sensitivity_hydro_SAR_dates_1month_',time_stamp_str,'Hr.mat'))
# matlab/aps_powerlaw.m:173
                else:
                    if hydro == 0 and wet == 1:
                        save_name=matlabarray(cat(sounding_dir,filesep,'Powerlaw',filesep,'Powerlaw_sensitivity_wet_SAR_dates_1month_',time_stamp_str,'Hr.mat'))
# matlab/aps_powerlaw.m:175
                    else:
                        save_name=matlabarray(cat(sounding_dir,filesep,'Powerlaw',filesep,'Powerlaw_sensitivity_SAR_dates_1month_',time_stamp_str,'Hr.mat'))
# matlab/aps_powerlaw.m:177
                n_months=1
# matlab/aps_powerlaw.m:179
            else:
                fprintf('Coefficient estimation based on average \\n\\n')
                # putting the variables in the right set-up
                start_year=str2num(sounding_start_date[1:4])
# matlab/aps_powerlaw.m:183
                end_year=str2num(sounding_end_date[1:4])
# matlab/aps_powerlaw.m:184
                start_str=sounding_start_date[5:6]
# matlab/aps_powerlaw.m:185
                end_str=sounding_end_date[5:6]
# matlab/aps_powerlaw.m:186
                if hydro == 1 and wet == 0:
                    save_name=matlabarray(cat(sounding_dir,filesep,'Powerlaw',filesep,'Powerlaw_sensitivity_hydro_',num2str(n_months),'month_',time_stamp_str,'Hr_',num2str(start_year),start_str,'_',num2str(end_year),end_str,'.mat'))
# matlab/aps_powerlaw.m:190
                else:
                    if hydro == 0 and wet == 1:
                        save_name=matlabarray(cat(sounding_dir,filesep,'Powerlaw',filesep,'Powerlaw_sensitivity_wet_',num2str(n_months),'month_',time_stamp_str,'Hr_',num2str(start_year),start_str,'_',num2str(end_year),end_str,'.mat'))
# matlab/aps_powerlaw.m:192
                    else:
                        save_name=matlabarray(cat(sounding_dir,filesep,'Powerlaw',filesep,'Powerlaw_sensitivity_',num2str(n_months),'month_',time_stamp_str,'Hr_',num2str(start_year),start_str,'_',num2str(end_year),end_str,'.mat'))
# matlab/aps_powerlaw.m:194
            if exist(save_name,'file') == 2:
                str=''
# matlab/aps_powerlaw.m:200
                while strcmpi(str,'y') != 1 and strcmpi(str,'n') != 1:

                    str=input_(cat('This file already exist, do you want to re-process the data? [y/n] \\n'),'s')
# matlab/aps_powerlaw.m:202

                if strcmpi(str,'y'):
                    sounding_powerlaw_sens(hydro,wet)
                else:
                    sounding_powerlaw_sens_display
            else:
                # estimate the coefficients for individual interferograms
                sounding_powerlaw_sens(hydro,wet)
        else:
            fprintf('Based on specified sounding period \\n\\n')
            # When having sounding data estimate the powerlaw and b coefficient
            alpha_log_all,alpha,h0,n_soundings=sounding
# matlab/aps_powerlaw.m:219
            fprintf('Updating the parm_aps list \\n')
            setparm_aps('powerlaw_h0',h0)
            setparm_aps('powerlaw_alpha',alpha)
            # saving the data
            save(cat(save_path,filesep,'aps_p_step1.mat'),'alpha','h0','look_angle','lambda','sounding_h0','sounding_h_alpha_thres','sounding_start_date','sounding_end_date','sounding_time_stamp')
    
    if start_step == 1 and strcmp(sounding_data,'n'):
        fprintf('\\n\\n Step 1: powerlaw coefficents set by user \\n\\n')
        # as set by the user
        h0=getparm_aps('powerlaw_h0')
# matlab/aps_powerlaw.m:236
        alpha=getparm_aps('powerlaw_alpha')
# matlab/aps_powerlaw.m:237
    
    ## PART 2: Rotate the dataset to get mimumal white space around it
# Scaling and interpolation of the data to a regular grid
    if start_step <= 2 and end_step >= 2:
        fprintf('\\n\\nStep 2: Rotate the dataset \\n')
        # getting the variables from the parm_aps file
        heading=getparm_aps('heading',1)
# matlab/aps_powerlaw.m:246
        crop_flag=getparm_aps('crop_flag',1)
# matlab/aps_powerlaw.m:247
        ll_matfile=getparm_aps('ll_matfile',1)
# matlab/aps_powerlaw.m:250
        ll=load(ll_matfile)
# matlab/aps_powerlaw.m:251
        ll=ll.lonlat
# matlab/aps_powerlaw.m:252
        h0=getparm_aps('powerlaw_h0',1)
# matlab/aps_powerlaw.m:255
        alpha=getparm_aps('powerlaw_alpha',1)
# matlab/aps_powerlaw.m:256
        getparm_aps('powerlaw_xy_res',1)
        phuw_matfile=getparm_aps('phuw_matfile',1)
# matlab/aps_powerlaw.m:258
        hgt_matfile=getparm_aps('hgt_matfile',1)
# matlab/aps_powerlaw.m:259
        DEM_corr=getparm_aps('powerlaw_DEM_corr',1)
# matlab/aps_powerlaw.m:260
        bperp_matfile=getparm_aps('bperp_matfile',1)
# matlab/aps_powerlaw.m:261
        xy_rotatelocal_full,xy_local_full,local_origin_full=ll2rotatelocal(ll,heading,nargout=3)
# matlab/aps_powerlaw.m:264
        crop=matlabarray([])
# matlab/aps_powerlaw.m:268
        if strcmpi(crop_flag,'y'):
            if exist('area_ex.mat','file') == 2:
                crop=load('area_ex.mat')
# matlab/aps_powerlaw.m:271
            else:
                if exist('../area_ex.mat','file') == 2:
                    crop=load('../area_ex.mat')
# matlab/aps_powerlaw.m:273
                else:
                    crop=matlabarray([])
# matlab/aps_powerlaw.m:275
                    fprintf(cat('There is no area_ex.mat file found, no data is cropped... \\n'))
        if logical_not(isempty(crop)):
            ix_remove=inpolygon(ll[:,1],ll[:,2],crop.lonlat(arange(),1),crop.lonlat(arange(),2))
# matlab/aps_powerlaw.m:280
        else:
            ix_remove=matlabarray([])
# matlab/aps_powerlaw.m:282
        ll[ix_remove,:]=[]
# matlab/aps_powerlaw.m:284
        ix_convexhull=convhull(ll[:,1],ll[:,2])
# matlab/aps_powerlaw.m:287
        InSAR_convexhull=ll[ix_convexhull,:]
# matlab/aps_powerlaw.m:288
        if exist('tca_support.mat','file') == 2:
            save('tca_support.mat','-append','InSAR_convexhull')
        else:
            save('tca_support.mat','InSAR_convexhull')
        clear('InSAR_convexhull')
        # rotating the data using all data including the region cropped. 
    # This will be used in the last stage of the power-law code.
        xy_rotatelocal,xy_local,local_origin=ll2rotatelocal(ll,heading,nargout=3)
# matlab/aps_powerlaw.m:300
        fprintf('        Scaling and interpolation to a regular grid \\n\\n')
        # loading the unwrapped interferograms
        ph=load(phuw_matfile)
# matlab/aps_powerlaw.m:305
        ph=ph.ph_uw
# matlab/aps_powerlaw.m:306
        ix_phase_nan=isnan(ph)
# matlab/aps_powerlaw.m:309
        ph[ix_remove,:]=[]
# matlab/aps_powerlaw.m:312
        hgt=load(hgt_matfile)
# matlab/aps_powerlaw.m:316
        hgt=hgt.hgt
# matlab/aps_powerlaw.m:317
        hgt[ix_remove,:]=[]
# matlab/aps_powerlaw.m:319
        n_interferograms=size(ph,2)
# matlab/aps_powerlaw.m:322
        n_points=size(ph,1)
# matlab/aps_powerlaw.m:323
        # ifg based powerlaw correction?
        if length(alpha) == n_interferograms:
            hgt_max=max(hgt)
# matlab/aps_powerlaw.m:328
            hgt_scaled=repmat(hgt,1,size(ph,2))
# matlab/aps_powerlaw.m:329
            ifg_based_correction='y'
# matlab/aps_powerlaw.m:330
            for k in arange(1,length(alpha)).reshape(-1):
                if dot(h0[k],1000) - hgt_max <= 0:
                    error('myApp:argChk',cat('Power law is not valid above h0 heights,... \\nAbort,... \\n'))
                hgt_scaled[:,k]=(dot(h0[k],1000) - hgt_scaled[:,k]) ** (alpha[k])
# matlab/aps_powerlaw.m:336
        else:
            # Scaling of the topography according to the powerlaw
            ifg_based_correction='n'
# matlab/aps_powerlaw.m:340
            ix=find(dot(h0,1000) - hgt < 0)
# matlab/aps_powerlaw.m:341
            if isempty(ix) != 1:
                error('myApp:argChk',cat('Power law is not valid above h0 heights,... \\nAbort,... \\n'))
            hgt_scaled=(dot(h0,1000) - hgt) ** (alpha)
# matlab/aps_powerlaw.m:345
        # define a new dataset were the height is actually the first column and
    # the interferograms are in the other columns
    # optional remove an estimate for the DEM errors
        if strcmp(DEM_corr,'y') and n_interferograms > 5:
            # loading the perpendicualr baseline information
            bperp=load(bperp_matfile)
# matlab/aps_powerlaw.m:354
            if strcmp(stamps_processed,'y'):
                bperp=bperp.bperp
# matlab/aps_powerlaw.m:356
            # checking the size of bperp
            if size(bperp,2) > 1:
                bperp=bperp.T
# matlab/aps_powerlaw.m:360
                if size(bperp,2) > 1:
                    error('myApp:argChk',cat('bperp is not a vector,... \\nAbort,... \\n'))
            # estimating the correlated errors
            DEM_corr_e=lscov(bperp,ph.T).T
# matlab/aps_powerlaw.m:366
            ph_temp=ph - multiply(repmat(bperp.T,n_points,1),repmat(DEM_corr_e,1,n_interferograms))
# matlab/aps_powerlaw.m:369
            dataset=matlabarray(cat(hgt_scaled,ph_temp))
# matlab/aps_powerlaw.m:370
            clear('ph_temp','A')
        else:
            if strcmp(DEM_corr,'y') and n_interferograms <= 5:
                fprintf('Not enough interferograms to make a reliable estimate for the DEM error \\n')
                DEM_corr='n'
# matlab/aps_powerlaw.m:375
            dataset=matlabarray(cat(hgt_scaled,ph))
# matlab/aps_powerlaw.m:377
            DEM_corr_e=zeros(cat(n_points,1))
# matlab/aps_powerlaw.m:378
        ## do an initial reference correction for each interferogram. 
    # This is to scope for regions that are small and which can have bandfiltering
    # arctifacts introduced. What happens is that each interferogram is
    # shifted such that the phase is zero at h0. Note that this is a long
    # wavelength shift that will be filtered out latter on. But in case of
    # irregularities it will reduce introduced arctifacts. To cope with
    # spatial varying signals this offset estimation is done over multiple
    # windows, but the constant offset is the same for all windows.     
    # get the position of some subwindows
        iterate=window_generation(xy_rotatelocal,1)
# matlab/aps_powerlaw.m:394
        counter=0
# matlab/aps_powerlaw.m:396
        for k in arange(1,length(iterate.window_ix)).reshape(-1):
            counter=counter + size(iterate.window_ix[k],1)
# matlab/aps_powerlaw.m:398
        for k in arange(1,n_interferograms).reshape(-1):
            # separate between ifg based correction or using a single alpha and h0
            if length(alpha) == n_interferograms:
                height_data=dataset[:,k]
# matlab/aps_powerlaw.m:404
                scaling=1.0 / nanmean(abs(dataset[:,k]))
# matlab/aps_powerlaw.m:405
                phase_data=dataset[:,n_interferograms + k]
# matlab/aps_powerlaw.m:406
            else:
                scaling=1.0 / nanmean(abs(dataset[:,1]))
# matlab/aps_powerlaw.m:408
                height_data=dataset[:,1]
# matlab/aps_powerlaw.m:409
                phase_data=dataset[:,1 + k]
# matlab/aps_powerlaw.m:410
            # estimating the reference, forced to be the same for all windows
            A_temp=zeros(cat(counter,length(iterate.window_ix)))
# matlab/aps_powerlaw.m:415
            data_temp=zeros(cat(counter,size(phase_data,2)))
# matlab/aps_powerlaw.m:416
            counter=1
# matlab/aps_powerlaw.m:417
            for kk in arange(1,length(iterate.window_ix)).reshape(-1):
                A_temp[counter:counter + size(iterate.window_ix[kk],1) - 1,kk]=dot(cat(height_data[iterate.window_ix[kk],1]),scaling)
# matlab/aps_powerlaw.m:419
                data_temp[counter:counter + size(iterate.window_ix[kk],1) - 1,:]=cat(phase_data[iterate.window_ix[kk],1])
# matlab/aps_powerlaw.m:420
                counter=counter + size(iterate.window_ix[kk],1)
# matlab/aps_powerlaw.m:421
            A_temp=matlabarray(cat(A_temp,ones(cat(size(data_temp,1),1))))
# matlab/aps_powerlaw.m:424
            #        ix = find(isnan(data_temp(:,1))~=1);
            ix=logical_not(((isnan(data_temp[:,1]) + sum(isnan(A_temp),2)) >= 1))
# matlab/aps_powerlaw.m:428
            coeff=lscov(A_temp[ix,:],data_temp[ix,1])
# matlab/aps_powerlaw.m:429
            if plot_flag == 1:
                figure('name',cat('Correction of the reference for ifg ',num2str(k)))
                subplot(2,1,1)
                plot(height_data,phase_data,'k.')
                if length(alpha) == n_interferograms:
                    temp=getparm_aps('powerlaw_alpha')
# matlab/aps_powerlaw.m:437
                    xlabel(cat('(h_0-h)^{',num2str(temp[k]),'}'))
                else:
                    xlabel(cat('(h_0-h)^{',num2str(getparm_aps('powerlaw_alpha')),'}'))
                ylabel('Phase')
            if plot_flag == 1:
                for kk in arange(1,length(iterate.window_ix)).reshape(-1):
                    y_temp=dot(cat(dot(cat(height_data[iterate.window_ix[kk],1]),scaling),ones(size(dot(cat(height_data[iterate.window_ix[kk],1]),scaling)))),cat(coeff[kk],coeff[end()]).T)
# matlab/aps_powerlaw.m:447
                    hold('on')
                    plot(cat(height_data[iterate.window_ix[kk],1]),y_temp,'r-')
                title('power-law plot with ifg reference to be the mean')
            # correct the data for the reference
            data_temp=data_temp - coeff[end()]
# matlab/aps_powerlaw.m:455
            if length(alpha) == n_interferograms:
                dataset[:,n_interferograms + k]=dataset[:,n_interferograms + k] - coeff[end()]
# matlab/aps_powerlaw.m:458
            else:
                dataset[:,k + 1]=dataset[:,k + 1] - coeff[end()]
# matlab/aps_powerlaw.m:460
            # plot the corrected result
            if plot_flag == 1:
                subplot(2,1,2)
                if length(alpha) == n_interferograms:
                    plot(dataset[:,k],dataset[:,n_interferograms + k],'k.')
                    temp=getparm_aps('powerlaw_alpha')
# matlab/aps_powerlaw.m:468
                    xlabel(cat('(h_0-h)^{',num2str(temp[k]),'}'))
                else:
                    plot(dataset[:,1],dataset[:,k + 1],'k.')
                    xlabel(cat('(h_0-h)^{',num2str(getparm_aps('powerlaw_alpha')),'}'))
                ylabel('Phase shifted to h0 reference')
                # plot line on top
                coeff=lscov(A_temp,data_temp[:,1])
# matlab/aps_powerlaw.m:477
                for kk in arange(1,length(iterate.window_ix)).reshape(-1):
                    if length(alpha) == n_interferograms:
                        y_temp=dot(cat(dot(cat(dataset[iterate.window_ix[kk],k]),scaling),ones(size(dot(cat(dataset[iterate.window_ix[kk],k]),scaling)))),cat(coeff[kk],coeff[end()]).T)
# matlab/aps_powerlaw.m:480
                    else:
                        y_temp=dot(cat(dot(cat(dataset[iterate.window_ix[kk],1]),scaling),ones(size(dot(cat(dataset[iterate.window_ix[kk],1]),scaling)))),cat(coeff[kk],coeff[end()]).T)
# matlab/aps_powerlaw.m:482
                    hold('on')
                    plot(cat(dataset[iterate.window_ix[kk],k]),y_temp,'r-')
                title('power law plot with h0 as reference')
        ## Extrapolate such the convexhull contains the full grid
        xy_res=getparm_aps('powerlaw_xy_res')
# matlab/aps_powerlaw.m:494
        xy_local_box,dataset_box=extrapolate_local_new(xy_rotatelocal,dataset,xy_res[1],xy_res[2],nargout=2)
# matlab/aps_powerlaw.m:495
        X_regular,Y_regular,Z_regular=interpolate_regular(xy_local_box,dataset_box,xy_res[1],xy_res[2],nargout=3)
# matlab/aps_powerlaw.m:498
        aps_save(cat(save_path,filesep,'aps_p_step2.mat'),xy_rotatelocal,xy_rotatelocal_full,ifg_based_correction,xy_local,xy_local_full,heading,ll,local_origin,local_origin_full,X_regular,Y_regular,Z_regular,xy_rotatelocal,xy_res,DEM_corr,DEM_corr_e,ix_remove,ix_phase_nan)
    
    ## PART 3: Bandfiltering and interpolation back to a local grid
    if start_step <= 3 and end_step >= 3:
        fprintf('Step 3: Bandfiltering of the regular grid and converting back to a local grid \\n\\n')
        # Loading the data from the previous step
        if start_step == 3:
            load(cat(save_path,filesep,'aps_p_step2.mat'))
        # loading the lonlat information
        ll_matfile=getparm_aps('ll_matfile')
# matlab/aps_powerlaw.m:516
        temp=load(ll_matfile)
# matlab/aps_powerlaw.m:517
        if strcmp(stamps_processed,'y'):
            temp=temp.lonlat
# matlab/aps_powerlaw.m:519
        n_points_original=size(temp,1)
# matlab/aps_powerlaw.m:522
        clear('temp')
        spatial_bands=getparm_aps('powerlaw_spatial_bands')
# matlab/aps_powerlaw.m:526
        bandfiltering(Z_regular,xy_res[1],xy_res[2],spatial_bands,save_path,ifg_based_correction)
        # Interpolate back to local grid
        n_datasets=size(Z_regular,3)
# matlab/aps_powerlaw.m:532
        fprintf(cat('*Interpolate the band filtered data to the local grid: \\n'))
        if strcmp(ifg_based_correction,'y'):
            h_ifg_number=n_datasets / 2
# matlab/aps_powerlaw.m:536
        else:
            h_ifg_number=1
# matlab/aps_powerlaw.m:538
        for k in arange(1,n_datasets).reshape(-1):
            # the file names, vary depending if the correction is varying for each interferogram
            if k <= h_ifg_number and h_ifg_number != 1:
                # thse are interferograms
                load_name=matlabarray(cat('bandfilter_regular_hgt_ifg_',num2str(k),'.mat'))
# matlab/aps_powerlaw.m:545
                save_name=matlabarray(cat('bandfilter_local_hgt_ifg',num2str(k),'.mat'))
# matlab/aps_powerlaw.m:546
            else:
                if k <= h_ifg_number and h_ifg_number == 1:
                    # these are the heights
                    load_name='bandfilter_regular_hgt.mat'
# matlab/aps_powerlaw.m:549
                    save_name='bandfilter_local_hgt.mat'
# matlab/aps_powerlaw.m:550
                else:
                    # thse are interferograms
                    load_name=matlabarray(cat('bandfilter_regular_ifg_',num2str(k - h_ifg_number),'.mat'))
# matlab/aps_powerlaw.m:553
                    save_name=matlabarray(cat('bandfilter_local_ifg_',num2str(k - h_ifg_number),'.mat'))
# matlab/aps_powerlaw.m:554
            dataset_band=load(cat(save_path,filesep,load_name))
# matlab/aps_powerlaw.m:557
            dimension_filter=dataset_band.dimension_filter
# matlab/aps_powerlaw.m:560
            # loading the data for each dataset
            dataset_band=dataset_band.data_band_out
# matlab/aps_powerlaw.m:562
            # note that this is xy_rotatelocal and does not include the cropped
        # region!
            z_local_out_temp=interpolate2local(X_regular,Y_regular,dataset_band,xy_rotatelocal)
# matlab/aps_powerlaw.m:567
            z_local_out=NaN(cat(n_points_original,size(z_local_out_temp,2)))
# matlab/aps_powerlaw.m:569
            if isempty(ix_remove):
                z_local_out=copy(z_local_out_temp)
# matlab/aps_powerlaw.m:572
            else:
                z_local_out[logical_not(ix_remove),:]=z_local_out_temp
# matlab/aps_powerlaw.m:574
            # Check in case some of the orginal phase values were nan.
        # if so set them to nan here too.
            if k <= h_ifg_number and h_ifg_number != 1:
                # these are interferograms heights not the phase. No need to
            # modify this here.
                pass
            else:
                if k <= h_ifg_number and h_ifg_number == 1:
                    # these are the heights, nothing needs to be done as the
            # heights remain the same for each interferogram.
                    pass
                else:
                    # these are interferograms
                    fprintf('Allowing for NaN\'s in the interferograms \\n')
                    z_local_out[ix_phase_nan[:,k - h_ifg_number],:]=NaN
# matlab/aps_powerlaw.m:588
            # saving the data for each dataset
            aps_save(cat(save_path,filesep,save_name),z_local_out,spatial_bands,dimension_filter)
            fprintf(cat('Progress: ',num2str(k),'/',num2str(n_datasets),' done \\n'))
        # Saving the results of this step
        aps_save(cat(save_path,filesep,'aps_p_step3.mat'),ifg_based_correction,n_datasets,local_origin,local_origin_full,xy_rotatelocal,xy_rotatelocal_full,DEM_corr,DEM_corr_e,dimension_filter,ix_remove,ix_phase_nan)
    
    ## PART 4: Estimating the scaling coefficient of the powerlaw for the local dataset 
# and computing the corresponding troposheric delay
    if start_step <= 4 and end_step >= 4:
        fprintf('\\n\\nStep 4: Estimating scaling coefficient of the powerlaw locally \\n')
        fprintf('and estimating the tropospheric interferometric phase delay \\n\\n')
        # Loading the data from the previous step
        if start_step == 4:
            load(cat(save_path,filesep,'aps_p_step3.mat'))
        # loading information from the parm file
        hgt_matfile=getparm_aps('hgt_matfile')
# matlab/aps_powerlaw.m:616
        powerlaw_all_bands=getparm_aps('powerlaw_all_bands')
# matlab/aps_powerlaw.m:617
        hgt=load(hgt_matfile)
# matlab/aps_powerlaw.m:618
        hgt=hgt.hgt
# matlab/aps_powerlaw.m:619
        if strcmp(ifg_based_correction,'y'):
            n_interferograms=n_datasets / 2
# matlab/aps_powerlaw.m:623
        else:
            n_interferograms=n_datasets - 1
# matlab/aps_powerlaw.m:625
        # initialization
        n_points=size(hgt,1)
# matlab/aps_powerlaw.m:630
        ph_tropo_powerlaw=NaN(cat(n_points,n_interferograms))
# matlab/aps_powerlaw.m:631
        K_tropo_powerlaw=NaN(cat(n_points,n_interferograms))
# matlab/aps_powerlaw.m:632
        perc_cons_K_powerlaw=NaN(cat(n_interferograms,1))
# matlab/aps_powerlaw.m:633
        if strcmp(powerlaw_all_bands,'y'):
            ph_tropo_powerlaw_bands=NaN(cat(n_points,n_interferograms,size(getparm_aps('powerlaw_spatial_bands'),1)))
# matlab/aps_powerlaw.m:635
            K_tropo_powerlaw_bands=NaN(cat(n_points,n_interferograms,size(getparm_aps('powerlaw_spatial_bands'),1)))
# matlab/aps_powerlaw.m:636
        # Linear estimation for multiple windows based on bandfitlered data
    # final slope value is estimated for reliable bands only
        iterate=matlabarray([])
# matlab/aps_powerlaw.m:642
        # processing only those images that are not dropped in case of stamps
        ix_ifgs=arange(1,n_interferograms)
# matlab/aps_powerlaw.m:647
        if strcmp(stamps_processed,'y'):
            ix_drop_ifgs=getparm('drop_ifg')
# matlab/aps_powerlaw.m:649
        else:
            ix_drop_ifgs=matlabarray([])
# matlab/aps_powerlaw.m:651
        ix_ifgs[ix_drop_ifgs]=[]
# matlab/aps_powerlaw.m:653
        for k in arange(1,length(ix_ifgs)).reshape(-1):
            ix_interferogram=ix_ifgs[k]
# matlab/aps_powerlaw.m:657
            if strcmp(ifg_based_correction,'y') and n_interferograms != 1:
                # the first dataset was set the be the topography
                topo_data=load(cat(save_path,filesep,'bandfilter_local_hgt_ifg',num2str(ix_interferogram),'.mat'))
# matlab/aps_powerlaw.m:662
                topo_data=topo_data.z_local_out
# matlab/aps_powerlaw.m:663
                phase_data=load(cat(save_path,filesep,'bandfilter_local_ifg_',num2str(ix_interferogram),'.mat'))
# matlab/aps_powerlaw.m:665
                phase_data=phase_data.z_local_out
# matlab/aps_powerlaw.m:666
                ifg_number=copy(k)
# matlab/aps_powerlaw.m:667
            else:
                # the first dataset was set the be the topography
                topo_data=load(cat(save_path,filesep,'bandfilter_local_hgt.mat'))
# matlab/aps_powerlaw.m:670
                topo_data=topo_data.z_local_out
# matlab/aps_powerlaw.m:671
                phase_data=load(cat(save_path,filesep,'bandfilter_local_ifg_',num2str(ix_interferogram),'.mat'))
# matlab/aps_powerlaw.m:673
                phase_data=phase_data.z_local_out
# matlab/aps_powerlaw.m:674
                ifg_number=1
# matlab/aps_powerlaw.m:675
            # keep the figures of the outlier rejection as validation
            if k == 0:
                save_path_outlier_windows=matlabarray(cat(save_path,filesep,'ifg_',num2str(ix_interferogram),'_outlier_window'))
# matlab/aps_powerlaw.m:680
            else:
                save_path_outlier_windows=matlabarray([])
# matlab/aps_powerlaw.m:682
            if k == 10000:
                debug_fig_linear=1
# matlab/aps_powerlaw.m:686
            else:
                debug_fig_linear=0
# matlab/aps_powerlaw.m:688
            ph_tropo_powerlaw_temp,ph_tropo_powerlaw_band_temp,iterate,K_temp,K_band,perc_cons_K=aps_powerlaw_linear_local(xy_rotatelocal_full,local_origin_full,topo_data,phase_data,iterate,dimension_filter,save_path_outlier_windows,ifg_number,ix_phase_nan[:,ix_interferogram],nargout=6)
# matlab/aps_powerlaw.m:691
            # Computation of the tropospheric delay for all ifgs
            ph_tropo_powerlaw[:,ix_interferogram]=ph_tropo_powerlaw_temp
# matlab/aps_powerlaw.m:696
            K_tropo_powerlaw[:,ix_interferogram]=K_temp
# matlab/aps_powerlaw.m:697
            perc_cons_K_powerlaw[ix_interferogram,1]=perc_cons_K
# matlab/aps_powerlaw.m:698
            if strcmp(powerlaw_all_bands,'y'):
                # keeping all bands with in the columns the ifgs and the third
            # dimention the bands
                ph_tropo_powerlaw_bands[:,ix_interferogram,:]=ph_tropo_powerlaw_band_temp
# matlab/aps_powerlaw.m:702
                K_tropo_powerlaw_bands[:,ix_interferogram,:]=K_band
# matlab/aps_powerlaw.m:703
                eval(cat('ph_tropo_powerlaw_ifg_',num2str(ix_interferogram),'= ph_tropo_powerlaw_band_temp;'))
                eval(cat('K_tropo_powerlaw_ifg_',num2str(ix_interferogram),'= K_band;'))
                clear('ph_tropo_powerlaw_band_temp')
                # saving the data from this step
                if strcmp(stamps_processed,'y'):
                    # This is StaMPS
                    if strcmp(getparm('small_baseline_flag'),'y'):
                        if exist(apsbandssbname,'file') == 2:
                            save(apsbandssbname,'-append',cat('ph_tropo_powerlaw_ifg_',num2str(ix_interferogram)),cat('K_tropo_powerlaw_ifg_',num2str(ix_interferogram)))
                        else:
                            save(apsbandssbname,cat('ph_tropo_powerlaw_ifg_',num2str(ix_interferogram)),cat('K_tropo_powerlaw_ifg_',num2str(ix_interferogram)))
                    else:
                        if exist(apsbandsname,'file') == 2:
                            save(apsbandsname,'-append',cat('ph_tropo_powerlaw_ifg_',num2str(ix_interferogram)),cat('K_tropo_powerlaw_ifg_',num2str(ix_interferogram)))
                        else:
                            save(apsbandsname,cat('ph_tropo_powerlaw_ifg_',num2str(ix_interferogram)),cat('K_tropo_powerlaw_ifg_',num2str(ix_interferogram)))
                else:
                    # This is not StaMPS
                    if exist(apsbandsname,'file') == 2:
                        save(apsbandsname,'-append',cat('ph_tropo_powerlaw_ifg_',num2str(ix_interferogram)),cat('K_tropo_powerlaw_ifg_',num2str(ix_interferogram)))
                    else:
                        save(apsbandsname,cat('ph_tropo_powerlaw_ifg_',num2str(ix_interferogram)),cat('K_tropo_powerlaw_ifg_',num2str(ix_interferogram)))
                eval(cat('clear ph_tropo_powerlaw_ifg_',num2str(ix_interferogram),' K_tropo_powerlaw_ifg_',num2str(ix_interferogram),';'))
            # give output to the screen
            fprintf(cat('Progress ifgs: ',num2str(k),'/',num2str(length(ix_ifgs)),' done \\n'))
        # saving the data from this step
        aps_save(cat(save_path,filesep,'aps_p_step4.mat'),ph_tropo_powerlaw,DEM_corr,DEM_corr_e,iterate,K_tropo_powerlaw)
        # saving the data into the final variable togehter were other
    # correction values are saved.
        ph_tropo_powerlaw_or=copy(ph_tropo_powerlaw)
# matlab/aps_powerlaw.m:745
        K_tropo_powerlaw_or=copy(K_tropo_powerlaw)
# matlab/aps_powerlaw.m:746
        if strcmp(stamps_processed,'y'):
            # This is StaMPS
            if strcmp(getparm('small_baseline_flag'),'y'):
                if exist(apssbname,'file') == 2:
                    save(apssbname,'-append','ph_tropo_powerlaw','K_tropo_powerlaw','perc_cons_K_powerlaw')
                else:
                    save(apssbname,'ph_tropo_powerlaw','K_tropo_powerlaw','perc_cons_K_powerlaw')
                # saving the band information
                if strcmpi(powerlaw_all_bands,'y'):
                    if exist(apsbandssbname,'file') == 2:
                        save(apsbandssbname,'-append','ph_tropo_powerlaw_or','K_tropo_powerlaw_or','ph_tropo_powerlaw_bands','K_tropo_powerlaw_bands','perc_cons_K_powerlaw')
                    else:
                        save(apsbandssbname,'ph_tropo_powerlaw_or','K_tropo_powerlaw_or','ph_tropo_powerlaw_bands','K_tropo_powerlaw_bands','perc_cons_K_powerlaw')
            else:
                # this is single master
                if exist(apsname,'file') == 2:
                    save(apsname,'-append','ph_tropo_powerlaw','K_tropo_powerlaw','perc_cons_K_powerlaw')
                else:
                    save(apsname,'ph_tropo_powerlaw','K_tropo_powerlaw','perc_cons_K_powerlaw')
                # saving the band information
                if strcmpi(powerlaw_all_bands,'y'):
                    if exist(apsbandsname,'file') == 2:
                        save(apsbandsname,'-append','ph_tropo_powerlaw_or','K_tropo_powerlaw_or','ph_tropo_powerlaw_bands','K_tropo_powerlaw_bands','perc_cons_K_powerlaw')
                    else:
                        save(apsbandsname,'ph_tropo_powerlaw_or','K_tropo_powerlaw_or','ph_tropo_powerlaw_bands','K_tropo_powerlaw_bands','perc_cons_K_powerlaw')
        else:
            # This is not StaMPS
            if exist(apsname,'file') == 2:
                save(apsname,'-append','ph_tropo_powerlaw','K_tropo_powerlaw','perc_cons_K_powerlaw')
            else:
                save(apsname,'ph_tropo_powerlaw','K_tropo_powerlaw','perc_cons_K_powerlaw')
            # saving the band information
            if strcmpi(powerlaw_all_bands,'y'):
                if exist(apsbandsname,'file') == 2:
                    save(apsbandsname,'-append','ph_tropo_powerlaw_or','K_tropo_powerlaw_or','ph_tropo_powerlaw_bands','K_tropo_powerlaw_bands','perc_cons_K_powerlaw')
                else:
                    save(apsbandsname,'ph_tropo_powerlaw_or','K_tropo_powerlaw_or','ph_tropo_powerlaw_bands','K_tropo_powerlaw_bands','perc_cons_K_powerlaw')
        setparm_aps('powerlaw_kept',cat(0))
    
    if start_step <= 5 and end_step >= 5 and exist('aps_RMSE_comparison') == 2:
        fprintf('\\n\\nStep 5: Powerlaw band comparison with reference\\n')
        if strcmpi(getparm_aps('stamps_processed'),'y'):
            # check which technique it needs to be compared with
            technique_number=- 10
# matlab/aps_powerlaw.m:807
            while isnumeric(technique_number) != logical_or(1,(technique_number < logical_or(1,technique_number) > 7)):

                technique_number=input_(cat('*Select the technique number you want to compare with: \\n---- MERIS (1), MODIS (2), MODIS Recal (3), ERA-I (4), WRF (5), u(sb) (6), u(sb)-d (7) : \\n'),'s')
# matlab/aps_powerlaw.m:809
                technique_number=floor(str2num(technique_number))
# matlab/aps_powerlaw.m:810

            # the technique component as a string
            if technique_number == 1:
                comp_str='a_mi'
# matlab/aps_powerlaw.m:814
            else:
                if technique_number == 2:
                    comp_str='a_MI'
# matlab/aps_powerlaw.m:816
                else:
                    if technique_number == 3:
                        comp_str='a_RMI'
# matlab/aps_powerlaw.m:818
                    else:
                        if technique_number == 4:
                            comp_str='a_e'
# matlab/aps_powerlaw.m:820
                        else:
                            if technique_number == 5:
                                comp_str='a_w'
# matlab/aps_powerlaw.m:822
                            else:
                                if technique_number == 6:
                                    if strcmpi(getparm('small_baseline_flag'),'y'):
                                        comp_str='usb'
# matlab/aps_powerlaw.m:825
                                    else:
                                        comp_str='u'
# matlab/aps_powerlaw.m:827
                                else:
                                    if technique_number == 7:
                                        if strcmpi(getparm('small_baseline_flag'),'y'):
                                            comp_str='usb-d'
# matlab/aps_powerlaw.m:831
                                        else:
                                            comp_str='u-d'
# matlab/aps_powerlaw.m:833
            # check if we should add the hydrostatic delays too in case this is
        # possible
            if technique_number == logical_or(1,technique_number) == logical_or(2,technique_number) == 3:
                hydro_comp=copy(inf)
# matlab/aps_powerlaw.m:840
                while isnumeric(hydro_comp) != logical_or(1,(hydro_comp < logical_or(0,hydro_comp) > 2)):

                    hydro_comp=input_(cat('*Do you want to add a hydrostatic component:\\n---- None (0), ERA-I hydr (1), WRF hydro (2): \\n'),'s')
# matlab/aps_powerlaw.m:842
                    hydro_comp=floor(str2num(hydro_comp))
# matlab/aps_powerlaw.m:843

            else:
                hydro_comp=0
# matlab/aps_powerlaw.m:846
            # the hydrostatic component as a string
            hydro_str=''
# matlab/aps_powerlaw.m:849
            if hydro_comp == 1:
                hydro_str='+a_eh'
# matlab/aps_powerlaw.m:851
            else:
                if hydro_comp == 2:
                    hydro_str='+a_wh'
# matlab/aps_powerlaw.m:853
            # The reference technique is combination of both
            tech_ref=matlabarray(cat(comp_str,hydro_str))
# matlab/aps_powerlaw.m:857
            clear('hydro_str','comp_str','technique_number','hydro_comp')
            # running the RMSE script
            aps_RMSE_comparison(tech_ref,'a_pbands')
            str=''
# matlab/aps_powerlaw.m:863
            while strcmpi(str,'y') != 1 and strcmpi(str,'n') != 1:

                str=input_(cat('Do you want to update \'powerlaw_kept\' to a different band? [y/n] \\n'),'s')
# matlab/aps_powerlaw.m:865

            if strcmpi(str,'y'):
                bandnumber=- 10
# matlab/aps_powerlaw.m:868
                while (bandnumber < logical_or(0,bandnumber) > size(getparm_aps('powerlaw_spatial_bands'),1)):

                    bandnumber=input_(cat('Which the band? (row number of the band to keep, or 0 for all bands combined) \\n'),'s')
# matlab/aps_powerlaw.m:870
                    bandnumber=str2num(bandnumber)
# matlab/aps_powerlaw.m:871
                    if isempty(bandnumber):
                        bandnumber=- 10
# matlab/aps_powerlaw.m:873

                setparm_aps('powerlaw_kept',cat(bandnumber))
        else:
            fprintf('This option uses the StaMPS ps_plot function, and therefore only works if your data is stamps processed \\n')
    