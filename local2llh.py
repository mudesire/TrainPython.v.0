# Autogenerated with SMOP 
from smop.core import *
# matlab/local2llh.m

    
@function
def local2llh(xy=None,origin=None,*args,**kwargs):
    varargin = local2llh.varargin
    nargin = local2llh.nargin

    #local2llh     llh=local2llh(xy,origin)
    
    #Converts from local coorindates to longitude and latitude 
#given the [lon, lat] of an origin. 'origin' should be in 
#decimal degrees. Note that heights are ignored and that 
#xy is in km.  Output is [lon, lat, height] in decimal 
#degrees. This is an iterative solution for the inverse of 
#a polyconic projection.
    
    #     Copyright (C) 2015
#     Email: eedpsb@leeds.ac.uk or davidbekaert.com
#     With permission by Peter Cervelli, Jessica Murray 
# 
#     This program is free software; you can redistribute it and/or modify
#     it under the terms of the GNU General Public License as published by
#     the Free Software Foundation; either version 2 of the License, or
#     (at your option) any later version.
# 
#     This program is distributed in the hope that it will be useful,
#     but WITHOUT ANY WARRANTY; without even the implied warranty of
#     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#     GNU General Public License for more details.
# 
#     You should have received a copy of the GNU General Public License along
#     with this program; if not, write to the Free Software Foundation, Inc.,
#     51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
    
    #-------------------------------------------------------------
#   Record of revisions:
    
    #   Date          Programmer            Description of Change
#   ====          ==========            =====================
    
    #   Aug 23, 2001  Jessica Murray        Clarification to help.
    
    #   Apr 4, 2001   Peter Cervelli        Added failsafe to avoid
#                                       infinite loop because of
#                                       covergence failure.
#   Sep 7, 2000   Peter Cervelli		Original Code
    
    #-------------------------------------------------------------
    
    #Set ellipsoid constants (WGS84)
    
    a=6378137.0
# matlab/local2llh.m:46
    e=0.0820944379497
# matlab/local2llh.m:47
    #Convert to radians / meters
    
    #   xy=xy*1000;
#   origin=origin*pi/180;
    xy=dot(double(xy),1000)
# matlab/local2llh.m:53
    origin=dot(double(origin),pi) / 180
# matlab/local2llh.m:54
    #Iterate to perform inverse projection
    
    M0=dot(a,(dot((1 - e ** 2 / 4 - dot(3,e ** 4) / 64 - dot(5,e ** 6) / 256),origin[2]) - dot((dot(3,e ** 2) / 8 + dot(3,e ** 4) / 32 + dot(45,e ** 6) / 1024),sin(dot(2,origin[2]))) + dot((dot(15,e ** 4) / 256 + dot(45,e ** 6) / 1024),sin(dot(4,origin[2]))) - dot((dot(35,e ** 6) / 3072),sin(dot(6,origin[2])))))
# matlab/local2llh.m:58
    z=xy[2,:] != - M0
# matlab/local2llh.m:63
    A=(M0 + xy[2,z]) / a
# matlab/local2llh.m:65
    B=xy[1,z] ** 2.0 / a ** 2 + A ** 2
# matlab/local2llh.m:66
    llh[2,z]=A
# matlab/local2llh.m:68
    delta=copy(Inf)
# matlab/local2llh.m:70
    c=0
# matlab/local2llh.m:72
    while max(abs(delta)) > 1e-08:

        C=multiply(sqrt((1 - dot(e ** 2,sin(llh[2,z]) ** 2))),tan(llh[2,z]))
# matlab/local2llh.m:76
        M=dot(a,(dot((1 - e ** 2 / 4 - dot(3,e ** 4) / 64 - dot(5,e ** 6) / 256),llh[2,z]) - dot((dot(3,e ** 2) / 8 + dot(3,e ** 4) / 32 + dot(45,e ** 6) / 1024),sin(dot(2,llh[2,z]))) + dot((dot(15,e ** 4) / 256 + dot(45,e ** 6) / 1024),sin(dot(4,llh[2,z]))) - dot((dot(35,e ** 6) / 3072),sin(dot(6,llh[2,z])))))
# matlab/local2llh.m:78
        Mn=1 - e ** 2 / 4 - dot(3,e ** 4) / 64 - dot(5,e ** 6) / 256 - dot(dot(- 2,(dot(3,e ** 2) / 8 + dot(3,e ** 4) / 32 + dot(45,e ** 6) / 1024)),cos(dot(2,llh[2,z]))) + dot(dot(4,(dot(15,e ** 4) / 256 + dot(45,e ** 6) / 1024)),cos(dot(4,llh[2,z]))) + dot(dot(- 6,(dot(35,e ** 6) / 3072)),cos(dot(6,llh[2,z])))
# matlab/local2llh.m:83
        Ma=M / a
# matlab/local2llh.m:88
        delta=- (multiply(A,(multiply(C,Ma) + 1)) - Ma - multiply(dot(0.5,(Ma ** 2 + B)),C)) / (multiply(dot(e ** 2,sin(dot(2,llh[2,z]))),(Ma ** 2 + B - multiply(dot(2,A),Ma))) / (dot(4,C)) + multiply((A - Ma),(multiply(C,Mn) - 2.0 / sin(dot(2,llh[2,z])))) - Mn)
# matlab/local2llh.m:90
        llh[2,z]=llh[2,z] + delta
# matlab/local2llh.m:93
        c=c + 1
# matlab/local2llh.m:95
        if c > 100:
            error('Convergence failure.')

    
    llh[1,z]=(asin(multiply(xy[1,z],C) / a)) / sin(llh[2,z]) + origin[1]
# matlab/local2llh.m:101
    #Handle special case of latitude = 0
    
    llh[1,logical_not(z)]=xy[1,logical_not(z)] / a + origin[1]
# matlab/local2llh.m:105
    llh[2,logical_not(z)]=0
# matlab/local2llh.m:106
    #Convert back to decimal degrees
    
    llh=dot(llh,180) / pi
# matlab/local2llh.m:110